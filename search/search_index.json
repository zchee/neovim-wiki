{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction FAQ Transitioning from Vim :help nvim-from-vim Related projects Google Summer of Code (GSoC) 2019 Users Install Following HEAD Documentation Developers Build Contribute Tests Refactoring guidelines Merging patches from upstream Vim Style guide Source Documentation Plugin Architecture Code overview C programming techniques and Neovim-specific guidance C refactorings and code-smells Integer type semantics Ideas Refactor Vim into a library Architectural musing and ideas (text buffer data structure, ...)","title":"Home"},{"location":"#users","text":"Install Following HEAD Documentation","title":"Users"},{"location":"#developers","text":"Build Contribute Tests Refactoring guidelines Merging patches from upstream Vim Style guide Source Documentation Plugin Architecture Code overview C programming techniques and Neovim-specific guidance C refactorings and code-smells Integer type semantics","title":"Developers"},{"location":"#ideas","text":"Refactor Vim into a library Architectural musing and ideas (text buffer data structure, ...)","title":"Ideas"},{"location":"Architectural-musing-and-ideas/","text":"Text/buffer representation Arguably, wrangling and displaying text are the most important things a text editor does. Vim represents text as a sequence of lines (see mem{line,file}.{c,h} , needs extra verification). Operations on lines are thus easy and efficient. It seems to be a good fit for the many operations Vim supports (undo/redo, text operators, ...). Even operations that are not necessarily line-based, like block mode operations, are easy to implement over a line-based API. Yet it is always instructive to learn about how other text editors tackle the issue. One of the disadvantages of the line-based approach seems to be that Vim has problems efficiently handling files that have no/little newlines. Think of large XML files that curiously have no newlines, it is often slow. Syntax highlighting is likely to blame in this case. More research is necessary to discover if this is can be remedied within the line-based structure, or if a different approach is necessary. Some alternative approaches: Piece Buffer As described in \"Data Structures for Text Sequences\" comments , pdf . Notably implemented in the vis text editor, which supports many Vim-like operators. Advantages: - Can mmap() the file into memory . This is the best way to seamlessly support editing huge files, especially on OS'es that do demand paging (all Neovim supported platforms do that). Disadvantages: - As noted by the vis author, text encoding conversion undoes the mmap() advantage mentioned above. A workaround might be possible, but it would really complicate the implementation. One idea for making it work is to make an overlay, see neovim/#1767 . Rope See wikipedia . TODO: more discussion on how it could be applied to Neovim. Gap Buffer See wikipedia . TODO: more discussion on how it could be applied to Neovim.","title":"Architectural-musing-and-ideas"},{"location":"Architectural-musing-and-ideas/#textbuffer-representation","text":"Arguably, wrangling and displaying text are the most important things a text editor does. Vim represents text as a sequence of lines (see mem{line,file}.{c,h} , needs extra verification). Operations on lines are thus easy and efficient. It seems to be a good fit for the many operations Vim supports (undo/redo, text operators, ...). Even operations that are not necessarily line-based, like block mode operations, are easy to implement over a line-based API. Yet it is always instructive to learn about how other text editors tackle the issue. One of the disadvantages of the line-based approach seems to be that Vim has problems efficiently handling files that have no/little newlines. Think of large XML files that curiously have no newlines, it is often slow. Syntax highlighting is likely to blame in this case. More research is necessary to discover if this is can be remedied within the line-based structure, or if a different approach is necessary. Some alternative approaches:","title":"Text/buffer representation"},{"location":"Architectural-musing-and-ideas/#piece-buffer","text":"As described in \"Data Structures for Text Sequences\" comments , pdf . Notably implemented in the vis text editor, which supports many Vim-like operators. Advantages: - Can mmap() the file into memory . This is the best way to seamlessly support editing huge files, especially on OS'es that do demand paging (all Neovim supported platforms do that). Disadvantages: - As noted by the vis author, text encoding conversion undoes the mmap() advantage mentioned above. A workaround might be possible, but it would really complicate the implementation. One idea for making it work is to make an overlay, see neovim/#1767 .","title":"Piece Buffer"},{"location":"Architectural-musing-and-ideas/#rope","text":"See wikipedia . TODO: more discussion on how it could be applied to Neovim.","title":"Rope"},{"location":"Architectural-musing-and-ideas/#gap-buffer","text":"See wikipedia . TODO: more discussion on how it could be applied to Neovim.","title":"Gap Buffer"},{"location":"Building-Neovim/","text":"Before upgrading to a new version, always check Following HEAD . Quick start Running tests Building Windows / MSVC Localization Compiler options Xcode and MSVC project files Custom Makefile Third-party dependencies Build prerequisites Quick start Verify that you have the build prerequisites installed. Clone neovim/neovim . If you want the stable release : git checkout stable Build Neovim by running make . (On BSD use gmake . On Windows see MSVC .) Set CMAKE_INSTALL_PREFIX if you want to install to a custom location . See Installing Neovim . Other notes: Third-party dependencies (libuv, LuaJIT, etc.) are downloaded automatically to .deps/ . See FAQ if you have issues. If you plan to develop Neovim, install ninja for faster builds. It will be used automatically. Now that you have the dependencies, you can try other build targets, explained below. Running tests See test/README.md Building Just make in the root of the repo will download and build all the needed dependencies and put the nvim executable at build/bin . Without installing, you can run it like this: VIMRUNTIME=runtime ./build/bin/nvim . The build type determines the level of used compiler optimisations and debug information: Release : Full compiler optimisations and no debug information. Expect the best performance from this build type. Often used by package maintainers. Debug : Full debug information; little optimisations. Use this for development to get meaningful output from debuggers like gdb or lldb. This is the default, if CMAKE_BUILD_TYPE is not specified. RelWithDebInfo (\"Release With Debug Info\"): Enables many optimisations and adds enough debug info so that when nvim ever crashes, you can still get a backtrace. So, for a release build, just use: make CMAKE_BUILD_TYPE=Release Afterwards, the nvim executable can be found at build/bin . To verify the build type after compilation, run ./build/bin/nvim --version | grep ^Build . To install the executable to a certain location, use: make CMAKE_INSTALL_PREFIX=$HOME/local/nvim install Cmake, our main build sytem, caches a lot of things in build/CMakeCache.txt . If you ever want to change CMAKE_BUILD_TYPE or CMAKE_INSTALL_PREFIX , run rm -rf build first. By default ( USE_BUNDLED=1 ), Nvim downloads and statically links its needed dependencies. In order to be able to use a debugger on these libraries, you might want to compile them with debug informations as well: make distclean VERBOSE=1 DEBUG=1 make deps (Here, make distclean is basically a shortcut for rm -rf build .deps .) Windows / MSVC Install Visual Studio (2017 or later) with the Desktop development with C++ workload. On 32-bit Windows you need [this workaround].( https://developercommunity.visualstudio.com/content/problem/212989/ninja-binary-format.html ) Open the Neovim project. Visual Studio automatically starts the build... IMPORTANT: Select x86-Release configuration instead of x64-{Debug,Release} . You can build with the x64-Release configuration if cmake -G \"Visual Studio 15 2017 Win64\" is used to build the dependencies. But the Debug configurations will not work because certain dependencies need to be linked with release version of the C runtime. If the build fails, it may be because VS started the build with x64-{Debug,Release} before you switched to x86-Release . Right-click CMakeLists.txt \u2192 Delete Cache . Right-click CMakeLists.txt \u2192 Generate Cache . Windows / CLion Install CLion . Open the Neovim project in CLion. Select Build \u2192 nvim.exe . Localization Localization build A normal build will create .mo files in build/src/nvim/po . If you see msgfmt: command not found , you need to install gettext . On most systems the package is just called gettext . Localization check To check the translations for $LANG , run make -C build check-po-$LANG . Examples: make -C build check-po-de make -C build check-po-pt_BR Use ninja instead of make if applicable. check-po-$LANG generates a detailed report in ./build/src/nvim/po/check-${LANG}.log . (The report is generated by nvim , not by msgfmt .) Localization update To update the src/nvim/po/$LANG.po file with the latest strings, run the following: make -C build update-po-$LANG Replace make with ninja if applicable. Note: run src/nvim/po/cleanup.vim after updating. Compiler options To see the chain of includes, use the -H option ( #918 ): echo '#include \"./src/nvim/buffer.h\"' | \\ > clang -I.deps/usr/include -Isrc -std=c99 -P -E -H - 2>&1 >/dev/null | \\ > grep -v /usr/ grep -v /usr/ is used to filter out system header files -save-temps can be added as well to see expanded macros or commented assembly Xcode and MSVC project files CMake has a -G option for exporting to multiple project file formats , such as Xcode and Visual Studio. For example, to use Xcode's static analysis GUI ( #167 ), you need to generate an Xcode project file from the Neovim makefile (where neovim/ is the top-level Neovim source code directory containing the main Makefile ): cmake -G Xcode neovim then open the resulting project file in Xcode. Custom Makefile You can customize the build process locally by creating a local.mk , which is referenced at the top of the main Makefile . It's listed in .gitignore so it can be used across branches. A new target in local.mk overrides the default make-target. Here's a sample local.mk which adds a target to force a rebuild but does not override the default-target: all : rebuild : rm -rf build make Third-party dependencies Reference the Debian package (or alternatively the Homebrew formula ) for the precise list of dependencies/versions. To build the bundled dependencies using CMake: mkdir .deps cd .deps cmake ../third-party make By default the libraries and headers are placed in .deps/usr . Now you can build Nvim: mkdir build cd build cmake .. make How to build without \"bundled\" dependencies Install the dependencies manually. For example on Debian/Ubuntu: sudo apt install gperf libluajit-5.1-dev libunibilium-dev libmsgpack-dev libtermkey-dev libvterm-dev libjemalloc-dev lua5.1 lua-lpeg lua-mpack lua-bitop Do the \"CMake dance\": create a build directory, switch to it and run CMake: mkdir build cd build cmake .. Run make , ninja , or whatever build tool you told CMake to generate for . Using ninja is strongly recommended. Build prerequisites General requirements (see #1469 ): Clang or GCC version 4.4+ CMake version 2.8.12+ , built with TLS/SSL support Optional: to get the latest CMake there are installers or a Python package ( pip install cmake ) Platform-specific requirements are listed below. Ubuntu / Debian sudo apt-get install ninja-build gettext libtool libtool-bin autoconf automake cmake g++ pkg-config unzip Note: libtool-bin is only required for Ubuntu 16.04/Debian Jessie and newer. CentOS / RHEL / Fedora If you're using CentOS/RHEL 6 you need at least autoconf version 2.69 for compiling the libuv dependency. See https://github.com/joyent/libuv/issues/1158 . sudo yum -y install ninja-build libtool autoconf automake cmake gcc gcc-c++ make pkgconfig unzip patch openSUSE sudo zypper install ninja libtool autoconf automake cmake gcc-c++ gettext-tools Arch Linux sudo pacman -S base-devel cmake unzip ninja Nix or NixOS Starting from nixos 18.03, the neovim binary resides in the neovim-unwrapped nix package (the neovim package being just a wrapper to setup runtime options like ruby/python support): cd path/to/neovim/src Drop into nix shell to pull in the neovim dependencies nix-shell '<nixpkgs>' -A neovim-unwrapped Configure and Build cmakeConfigurePhase buildPhase Tests are not available by default because of some unfixed failures. You can enable them via adding this package in your overlay: neovim-dev = (super.pkgs.neovim-unwrapped.override { doCheck=true; }).overrideAttrs(oa:{ cmakeBuildType=\"debug\"; nativeBuildInputs = oa.nativeBuildInputs ++ [ self.pkgs.valgrind ]; shellHook = '' export NVIM_PYTHON_LOG_LEVEL=DEBUG export NVIM_LOG_FILE=/tmp/log export VALGRIND_LOG=\"$PWD/valgrind.log\" ''; }); and replacing neovim-unwrapped by neovim-dev: $ nix-shell '<nixpkgs>' -A neovim-dev FreeBSD sudo pkg install cmake gmake libtool sha automake pkgconf unzip wget gettext If you get an error regarding a sha256sum mismatch, where the actual sha256sum is e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 , then this is your issue (that's the sha256sum of an empty file). Also, make sure you have wget installed. LuaRocks has bad interactions with cURL, at least under FreeBSD, and will die with a PANIC in LuaJIT when trying to install a rock. OpenBSD doas pkg_add gmake cmake libtool unzip autoconf-2.69p2 automake-1.15p0 export AUTOCONF_VERSION=2.69 export AUTOMAKE_VERSION=1.15 For older versions of OpenBSD than 6.1, the autoconf-2.69 and automake-1.15 ports may have different p suffixes. The build sometimes fails when using the top level Makefile, apparently due to some third-party component #2445-comment . The following instructions use CMake mkdir .deps cd .deps cmake ../third-party/ gmake cd .. mkdir build cd build cmake .. gmake macOS Install Xcode and Homebrew or MacPorts Install Xcode commandline tools xcode-select --install Install other dependencies: via MacPorts: sudo port install ninja libtool autoconf automake cmake pkgconfig gettext via Homebrew: brew install ninja libtool automake cmake pkg-config gettext If you see wget certificate errors (for macOS before version 10.10/Yosemite): via MacPorts: sudo port install curl-ca-bundle echo CA_CERTIFICATE=/opt/local/share/curl/curl-ca-bundle.crt >> ~/.wgetrc via Homebrew: brew install curl-ca-bundle echo CA_CERTIFICATE=$(brew --prefix curl-ca-bundle)/share/ca-bundle.crt >> ~/.wgetrc If you see 'stdio.h' file not found open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg Building for older macOS versions To build for older macOS versions, e.g. for 10.13, on a newer macOS, you have to set the macOS deployment target make CMAKE_BUILD_TYPE=Release MACOSX_DEPLOYMENT_TARGET=10.13 DEPS_CMAKE_FLAGS=\"-DCMAKE_CXX_COMPILER=$(xcrun -find c++)\" Note that if we do not explicitly set the C++ compiler, the compiler will not be found when the deployment target is set. cygwin Install all dependencies the normal way, then build neovim the normal way for a random CMake application (i.e. do not use the Makefile that automatically downloads and builds \"bundled\" dependencies) The cygport repo contains cygport files (like APKBUILD, PKGBUILD, etc.) for all the dependencies not available in the cygwin distribution, and describes any special commands or arguments needed to build. the cygport definitions also try to describe the required dependencies for each one. unless custom commands are provided, cygport just calls autogen/cmake, make, make install, etc. in a clean, consistent way. https://github.com/cascent/neovim-cygwin was built on cygwin 2.9.0. Newer libuv should require slightly less patching and some ssp stuff changed in cygwin 2.10.0 so that might change things too when building neovim. Windows / MSYS2 From the MSYS2 shell install these packages pacman -S \\ mingw-w64-x86_64-{gcc,libtool,cmake,make,perl,python2,pkg-config,unibilium} \\ gperf Now from the windows console (cmd.exe) setup the PATH and build set PATH=c:\\msys64\\mingw64\\bin;%PATH% set CC=gcc Build using the MinGW Makefiles generator mkdir .deps cd .deps cmake -G \"MinGW Makefiles\" ..\\third-party\\ mingw32-make cd .. mkdir build cd build cmake -G \"MinGW Makefiles\" -DGPERF_PRG=\"C:\\msys64\\usr\\bin\\gperf.exe\" .. mingw32-make For 32bit builds adjust the package names and paths accordingly.","title":"Building-Neovim"},{"location":"Building-Neovim/#quick-start","text":"Verify that you have the build prerequisites installed. Clone neovim/neovim . If you want the stable release : git checkout stable Build Neovim by running make . (On BSD use gmake . On Windows see MSVC .) Set CMAKE_INSTALL_PREFIX if you want to install to a custom location . See Installing Neovim . Other notes: Third-party dependencies (libuv, LuaJIT, etc.) are downloaded automatically to .deps/ . See FAQ if you have issues. If you plan to develop Neovim, install ninja for faster builds. It will be used automatically. Now that you have the dependencies, you can try other build targets, explained below.","title":"Quick start"},{"location":"Building-Neovim/#running-tests","text":"See test/README.md","title":"Running tests"},{"location":"Building-Neovim/#building","text":"Just make in the root of the repo will download and build all the needed dependencies and put the nvim executable at build/bin . Without installing, you can run it like this: VIMRUNTIME=runtime ./build/bin/nvim . The build type determines the level of used compiler optimisations and debug information: Release : Full compiler optimisations and no debug information. Expect the best performance from this build type. Often used by package maintainers. Debug : Full debug information; little optimisations. Use this for development to get meaningful output from debuggers like gdb or lldb. This is the default, if CMAKE_BUILD_TYPE is not specified. RelWithDebInfo (\"Release With Debug Info\"): Enables many optimisations and adds enough debug info so that when nvim ever crashes, you can still get a backtrace. So, for a release build, just use: make CMAKE_BUILD_TYPE=Release Afterwards, the nvim executable can be found at build/bin . To verify the build type after compilation, run ./build/bin/nvim --version | grep ^Build . To install the executable to a certain location, use: make CMAKE_INSTALL_PREFIX=$HOME/local/nvim install Cmake, our main build sytem, caches a lot of things in build/CMakeCache.txt . If you ever want to change CMAKE_BUILD_TYPE or CMAKE_INSTALL_PREFIX , run rm -rf build first. By default ( USE_BUNDLED=1 ), Nvim downloads and statically links its needed dependencies. In order to be able to use a debugger on these libraries, you might want to compile them with debug informations as well: make distclean VERBOSE=1 DEBUG=1 make deps (Here, make distclean is basically a shortcut for rm -rf build .deps .)","title":"Building"},{"location":"Building-Neovim/#windows-msvc","text":"Install Visual Studio (2017 or later) with the Desktop development with C++ workload. On 32-bit Windows you need [this workaround].( https://developercommunity.visualstudio.com/content/problem/212989/ninja-binary-format.html ) Open the Neovim project. Visual Studio automatically starts the build... IMPORTANT: Select x86-Release configuration instead of x64-{Debug,Release} . You can build with the x64-Release configuration if cmake -G \"Visual Studio 15 2017 Win64\" is used to build the dependencies. But the Debug configurations will not work because certain dependencies need to be linked with release version of the C runtime. If the build fails, it may be because VS started the build with x64-{Debug,Release} before you switched to x86-Release . Right-click CMakeLists.txt \u2192 Delete Cache . Right-click CMakeLists.txt \u2192 Generate Cache .","title":"Windows / MSVC"},{"location":"Building-Neovim/#windows-clion","text":"Install CLion . Open the Neovim project in CLion. Select Build \u2192 nvim.exe .","title":"Windows / CLion"},{"location":"Building-Neovim/#localization","text":"","title":"Localization"},{"location":"Building-Neovim/#localization-build","text":"A normal build will create .mo files in build/src/nvim/po . If you see msgfmt: command not found , you need to install gettext . On most systems the package is just called gettext .","title":"Localization build"},{"location":"Building-Neovim/#localization-check","text":"To check the translations for $LANG , run make -C build check-po-$LANG . Examples: make -C build check-po-de make -C build check-po-pt_BR Use ninja instead of make if applicable. check-po-$LANG generates a detailed report in ./build/src/nvim/po/check-${LANG}.log . (The report is generated by nvim , not by msgfmt .)","title":"Localization check"},{"location":"Building-Neovim/#localization-update","text":"To update the src/nvim/po/$LANG.po file with the latest strings, run the following: make -C build update-po-$LANG Replace make with ninja if applicable. Note: run src/nvim/po/cleanup.vim after updating.","title":"Localization update"},{"location":"Building-Neovim/#compiler-options","text":"To see the chain of includes, use the -H option ( #918 ): echo '#include \"./src/nvim/buffer.h\"' | \\ > clang -I.deps/usr/include -Isrc -std=c99 -P -E -H - 2>&1 >/dev/null | \\ > grep -v /usr/ grep -v /usr/ is used to filter out system header files -save-temps can be added as well to see expanded macros or commented assembly","title":"Compiler options"},{"location":"Building-Neovim/#xcode-and-msvc-project-files","text":"CMake has a -G option for exporting to multiple project file formats , such as Xcode and Visual Studio. For example, to use Xcode's static analysis GUI ( #167 ), you need to generate an Xcode project file from the Neovim makefile (where neovim/ is the top-level Neovim source code directory containing the main Makefile ): cmake -G Xcode neovim then open the resulting project file in Xcode.","title":"Xcode and MSVC project files"},{"location":"Building-Neovim/#custom-makefile","text":"You can customize the build process locally by creating a local.mk , which is referenced at the top of the main Makefile . It's listed in .gitignore so it can be used across branches. A new target in local.mk overrides the default make-target. Here's a sample local.mk which adds a target to force a rebuild but does not override the default-target: all : rebuild : rm -rf build make","title":"Custom Makefile"},{"location":"Building-Neovim/#third-party-dependencies","text":"Reference the Debian package (or alternatively the Homebrew formula ) for the precise list of dependencies/versions. To build the bundled dependencies using CMake: mkdir .deps cd .deps cmake ../third-party make By default the libraries and headers are placed in .deps/usr . Now you can build Nvim: mkdir build cd build cmake .. make","title":"Third-party dependencies"},{"location":"Building-Neovim/#how-to-build-without-bundled-dependencies","text":"Install the dependencies manually. For example on Debian/Ubuntu: sudo apt install gperf libluajit-5.1-dev libunibilium-dev libmsgpack-dev libtermkey-dev libvterm-dev libjemalloc-dev lua5.1 lua-lpeg lua-mpack lua-bitop Do the \"CMake dance\": create a build directory, switch to it and run CMake: mkdir build cd build cmake .. Run make , ninja , or whatever build tool you told CMake to generate for . Using ninja is strongly recommended.","title":"How to build without \"bundled\" dependencies"},{"location":"Building-Neovim/#build-prerequisites","text":"General requirements (see #1469 ): Clang or GCC version 4.4+ CMake version 2.8.12+ , built with TLS/SSL support Optional: to get the latest CMake there are installers or a Python package ( pip install cmake ) Platform-specific requirements are listed below.","title":"Build prerequisites"},{"location":"Building-Neovim/#ubuntu-debian","text":"sudo apt-get install ninja-build gettext libtool libtool-bin autoconf automake cmake g++ pkg-config unzip Note: libtool-bin is only required for Ubuntu 16.04/Debian Jessie and newer.","title":"Ubuntu / Debian"},{"location":"Building-Neovim/#centos-rhel-fedora","text":"If you're using CentOS/RHEL 6 you need at least autoconf version 2.69 for compiling the libuv dependency. See https://github.com/joyent/libuv/issues/1158 . sudo yum -y install ninja-build libtool autoconf automake cmake gcc gcc-c++ make pkgconfig unzip patch","title":"CentOS / RHEL / Fedora"},{"location":"Building-Neovim/#opensuse","text":"sudo zypper install ninja libtool autoconf automake cmake gcc-c++ gettext-tools","title":"openSUSE"},{"location":"Building-Neovim/#arch-linux","text":"sudo pacman -S base-devel cmake unzip ninja","title":"Arch Linux"},{"location":"Building-Neovim/#nix-or-nixos","text":"Starting from nixos 18.03, the neovim binary resides in the neovim-unwrapped nix package (the neovim package being just a wrapper to setup runtime options like ruby/python support): cd path/to/neovim/src Drop into nix shell to pull in the neovim dependencies nix-shell '<nixpkgs>' -A neovim-unwrapped Configure and Build cmakeConfigurePhase buildPhase Tests are not available by default because of some unfixed failures. You can enable them via adding this package in your overlay: neovim-dev = (super.pkgs.neovim-unwrapped.override { doCheck=true; }).overrideAttrs(oa:{ cmakeBuildType=\"debug\"; nativeBuildInputs = oa.nativeBuildInputs ++ [ self.pkgs.valgrind ]; shellHook = '' export NVIM_PYTHON_LOG_LEVEL=DEBUG export NVIM_LOG_FILE=/tmp/log export VALGRIND_LOG=\"$PWD/valgrind.log\" ''; }); and replacing neovim-unwrapped by neovim-dev: $ nix-shell '<nixpkgs>' -A neovim-dev","title":"Nix or NixOS"},{"location":"Building-Neovim/#freebsd","text":"sudo pkg install cmake gmake libtool sha automake pkgconf unzip wget gettext If you get an error regarding a sha256sum mismatch, where the actual sha256sum is e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 , then this is your issue (that's the sha256sum of an empty file). Also, make sure you have wget installed. LuaRocks has bad interactions with cURL, at least under FreeBSD, and will die with a PANIC in LuaJIT when trying to install a rock.","title":"FreeBSD"},{"location":"Building-Neovim/#openbsd","text":"doas pkg_add gmake cmake libtool unzip autoconf-2.69p2 automake-1.15p0 export AUTOCONF_VERSION=2.69 export AUTOMAKE_VERSION=1.15 For older versions of OpenBSD than 6.1, the autoconf-2.69 and automake-1.15 ports may have different p suffixes. The build sometimes fails when using the top level Makefile, apparently due to some third-party component #2445-comment . The following instructions use CMake mkdir .deps cd .deps cmake ../third-party/ gmake cd .. mkdir build cd build cmake .. gmake","title":"OpenBSD"},{"location":"Building-Neovim/#macos","text":"Install Xcode and Homebrew or MacPorts Install Xcode commandline tools xcode-select --install Install other dependencies: via MacPorts: sudo port install ninja libtool autoconf automake cmake pkgconfig gettext via Homebrew: brew install ninja libtool automake cmake pkg-config gettext If you see wget certificate errors (for macOS before version 10.10/Yosemite): via MacPorts: sudo port install curl-ca-bundle echo CA_CERTIFICATE=/opt/local/share/curl/curl-ca-bundle.crt >> ~/.wgetrc via Homebrew: brew install curl-ca-bundle echo CA_CERTIFICATE=$(brew --prefix curl-ca-bundle)/share/ca-bundle.crt >> ~/.wgetrc If you see 'stdio.h' file not found open /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg","title":"macOS"},{"location":"Building-Neovim/#building-for-older-macos-versions","text":"To build for older macOS versions, e.g. for 10.13, on a newer macOS, you have to set the macOS deployment target make CMAKE_BUILD_TYPE=Release MACOSX_DEPLOYMENT_TARGET=10.13 DEPS_CMAKE_FLAGS=\"-DCMAKE_CXX_COMPILER=$(xcrun -find c++)\" Note that if we do not explicitly set the C++ compiler, the compiler will not be found when the deployment target is set.","title":"Building for older macOS versions"},{"location":"Building-Neovim/#cygwin","text":"Install all dependencies the normal way, then build neovim the normal way for a random CMake application (i.e. do not use the Makefile that automatically downloads and builds \"bundled\" dependencies) The cygport repo contains cygport files (like APKBUILD, PKGBUILD, etc.) for all the dependencies not available in the cygwin distribution, and describes any special commands or arguments needed to build. the cygport definitions also try to describe the required dependencies for each one. unless custom commands are provided, cygport just calls autogen/cmake, make, make install, etc. in a clean, consistent way. https://github.com/cascent/neovim-cygwin was built on cygwin 2.9.0. Newer libuv should require slightly less patching and some ssp stuff changed in cygwin 2.10.0 so that might change things too when building neovim.","title":"cygwin"},{"location":"Building-Neovim/#windows-msys2","text":"From the MSYS2 shell install these packages pacman -S \\ mingw-w64-x86_64-{gcc,libtool,cmake,make,perl,python2,pkg-config,unibilium} \\ gperf Now from the windows console (cmd.exe) setup the PATH and build set PATH=c:\\msys64\\mingw64\\bin;%PATH% set CC=gcc Build using the MinGW Makefiles generator mkdir .deps cd .deps cmake -G \"MinGW Makefiles\" ..\\third-party\\ mingw32-make cd .. mkdir build cd build cmake -G \"MinGW Makefiles\" -DGPERF_PRG=\"C:\\msys64\\usr\\bin\\gperf.exe\" .. mingw32-make For 32bit builds adjust the package names and paths accordingly.","title":"Windows / MSYS2"},{"location":"C-Refactorings-and-Code-Smells-Catalog/","text":"Neovim is a big refactoring effort. Bringing ideas from the literature on this subject should help. Contributors should be encouraged to detect bad code smells and apply the necessary refactorings with the caution that's necessary when dealing with old/undocumented/untested code. The lists here are not exhaustive and should not be seen as a perfect prescription for the problems that may be found in code. Be flexible. Catalog of C Refactorings A catalog of C refactorings that may guide us while improving neovim's codebase. From Garrido 2000 2.1 Proposal for a List of C Refactorings (page 17) Adding a Program Entity Add a variable Add a parameter to a function Add a typedef definition encapsulating an existing type Add a field to a structure Add a pointer to a variable: add a declaration of a pointer variable with pointed type equal to the type of the selected variable, and assign to the pointer the address of the selected variable. Deleting a Program Entity Delete unused variable Delete unused parameter Delete a function Changing a Program Entity Rename variable Rename constant Rename user-defined type Rename structure field Rename function Replace the type of a program entity Contract variable scope Extend variable scope Replace value with constant Replace expression with variable Convert variable to pointer Convert pointer to direct variable access Convert global variable into parameter: find all functions that access the given global variable. For each of the functions, add a formal parameter to the function definition, add the global variable as an actual parameter in the function call, and replace access to the global variable inside the function for the parameter. The user may choose if the parameter should be a pointer type. Reorder function arguments: reorder the arguments in a function definition and in all calls to that function. Complex refactorings Group a set of variables in a new structure: (e.g., #775 ) legacy systems often overuse global variables, which make a program non-reusable. Most changes, as minor as they can be, require global update. However, programmers use global variables when they otherwise should pass many of them as parameters. Passing too many parameters to a function can increase the calling time. The remedy to this problem is to define data structures grouping isolated variables, and pass a single reference to the structure as parameter. This refactoring defines structures by grouping existing variables. The second part of converting global access to parameters by reference is handled by the refactorings \"Convert global variable into parameter\". * Extract function : replace a complicated expression or statement list with a function call. As pointed out in [Fowler 99], this is a very common transformation. When a function gets too long or complicated, a good practice is to divide it into smaller fragments, turn each fragment into a function and replace the long function for a shorter one with function calls. The code extracted is scanned and for each reference to local variables in the source function, a parameter is added to the extracted function. I (@philix) no longer recommend function extraction as a good refactoring pattern. I think one should only extract functions when (1) the new function can be pure ( https://en.wikipedia.org/wiki/Pure_function ) or (2)there's already a concrete case of reuse. John Carmack discusses this topic on John Carmack on Inlined Code . * Inline function * Consolidate conditional expression : join adjacent cases in switch. * For into while * While into for * While into do while: transform the statement, reversing the condition of the while for the do while. Code Smells List of code smells by Jeff Atwood that may indicate solvable problems and inspire neovim contributors. This list was made for object oriented programming, but it's not hard to see how most of them apply to C. Code Smells Within Classes (.c files) Comments Long Method (long functions) Long Parameter List Duplicated Code Conditional Complexity Combinatorial Explosion Large Class (large .c files) Type Embedded in Name Uncommunicative Name Inconsistent Names Dead Code Speculative Generality Oddball Solution Temporary Field (temporary global variable) Code Smells Between Classes (between .c files) Alternative Classes with Different Interfaces Primitive Obsession #775 Data Class Data Clumps Refused Bequest Inappropriate Intimacy Indecent Exposure Feature Envy Lazy Class Message Chains Middle Man Divergent Change Shotgun Surgery Parallel Inheritance Hierarchies Incomplete Library Class Solution Sprawl C Refactoring Tools Coccinelle http://coccinelle.lip6.fr/ See #690 for an example of what it can do.","title":"C-Refactorings-and-Code-Smells-Catalog"},{"location":"C-Refactorings-and-Code-Smells-Catalog/#catalog-of-c-refactorings","text":"A catalog of C refactorings that may guide us while improving neovim's codebase. From Garrido 2000 2.1 Proposal for a List of C Refactorings (page 17)","title":"Catalog of C Refactorings"},{"location":"C-Refactorings-and-Code-Smells-Catalog/#adding-a-program-entity","text":"Add a variable Add a parameter to a function Add a typedef definition encapsulating an existing type Add a field to a structure Add a pointer to a variable: add a declaration of a pointer variable with pointed type equal to the type of the selected variable, and assign to the pointer the address of the selected variable.","title":"Adding a Program Entity"},{"location":"C-Refactorings-and-Code-Smells-Catalog/#deleting-a-program-entity","text":"Delete unused variable Delete unused parameter Delete a function","title":"Deleting a Program Entity"},{"location":"C-Refactorings-and-Code-Smells-Catalog/#changing-a-program-entity","text":"Rename variable Rename constant Rename user-defined type Rename structure field Rename function Replace the type of a program entity Contract variable scope Extend variable scope Replace value with constant Replace expression with variable Convert variable to pointer Convert pointer to direct variable access Convert global variable into parameter: find all functions that access the given global variable. For each of the functions, add a formal parameter to the function definition, add the global variable as an actual parameter in the function call, and replace access to the global variable inside the function for the parameter. The user may choose if the parameter should be a pointer type. Reorder function arguments: reorder the arguments in a function definition and in all calls to that function.","title":"Changing a Program Entity"},{"location":"C-Refactorings-and-Code-Smells-Catalog/#complex-refactorings","text":"Group a set of variables in a new structure: (e.g., #775 ) legacy systems often overuse global variables, which make a program non-reusable. Most changes, as minor as they can be, require global update. However, programmers use global variables when they otherwise should pass many of them as parameters. Passing too many parameters to a function can increase the calling time. The remedy to this problem is to define data structures grouping isolated variables, and pass a single reference to the structure as parameter. This refactoring defines structures by grouping existing variables. The second part of converting global access to parameters by reference is handled by the refactorings \"Convert global variable into parameter\". * Extract function : replace a complicated expression or statement list with a function call. As pointed out in [Fowler 99], this is a very common transformation. When a function gets too long or complicated, a good practice is to divide it into smaller fragments, turn each fragment into a function and replace the long function for a shorter one with function calls. The code extracted is scanned and for each reference to local variables in the source function, a parameter is added to the extracted function. I (@philix) no longer recommend function extraction as a good refactoring pattern. I think one should only extract functions when (1) the new function can be pure ( https://en.wikipedia.org/wiki/Pure_function ) or (2)there's already a concrete case of reuse. John Carmack discusses this topic on John Carmack on Inlined Code . * Inline function * Consolidate conditional expression : join adjacent cases in switch. * For into while * While into for * While into do while: transform the statement, reversing the condition of the while for the do while.","title":"Complex refactorings"},{"location":"C-Refactorings-and-Code-Smells-Catalog/#code-smells","text":"List of code smells by Jeff Atwood that may indicate solvable problems and inspire neovim contributors. This list was made for object oriented programming, but it's not hard to see how most of them apply to C.","title":"Code Smells"},{"location":"C-Refactorings-and-Code-Smells-Catalog/#code-smells-within-classes-c-files","text":"Comments Long Method (long functions) Long Parameter List Duplicated Code Conditional Complexity Combinatorial Explosion Large Class (large .c files) Type Embedded in Name Uncommunicative Name Inconsistent Names Dead Code Speculative Generality Oddball Solution Temporary Field (temporary global variable)","title":"Code Smells Within Classes (.c files)"},{"location":"C-Refactorings-and-Code-Smells-Catalog/#code-smells-between-classes-between-c-files","text":"Alternative Classes with Different Interfaces Primitive Obsession #775 Data Class Data Clumps Refused Bequest Inappropriate Intimacy Indecent Exposure Feature Envy Lazy Class Message Chains Middle Man Divergent Change Shotgun Surgery Parallel Inheritance Hierarchies Incomplete Library Class Solution Sprawl","title":"Code Smells Between Classes (between .c files)"},{"location":"C-Refactorings-and-Code-Smells-Catalog/#c-refactoring-tools","text":"","title":"C Refactoring Tools"},{"location":"C-Refactorings-and-Code-Smells-Catalog/#coccinelle","text":"http://coccinelle.lip6.fr/ See #690 for an example of what it can do.","title":"Coccinelle"},{"location":"C-programming/","text":"C programming techniques and Neovim-specific guidance sizeof sizeof(<var>) vs sizeof(<type>) something you have to be really careful about: the difference between arrays and pointers [...] be judicious: if the variable is simple (int, long, ...), use sizeof(variable) , if the variable is complex (struct, pointer-to-pointer, ...), use sizeof(the_actual_type) . Scope It is undefined behavior to access a pointer that was assigned in an inner scope . Struct organization https://github.com/neovim/neovim/pull/656#issuecomment-41905534 TODO: link to discussion of legacy Vim struct hack Unsigned or signed? Integer overflow/underflow Conversion of signed variables to unsigned (in files not checked by -Wconversion ) There are a few very important things to keep in mind while choosing between signed and unsigned integral types: Firstly, unsigned overflow is defined , while signed overflow is not . This is an unfortunate historical oversight stemming from a time where it wasn't sure what representation a signed integer would have . The C standard decided that it shouldn't/couldn't specify what would happen when a signed integer overflows, because each representation would have different behaviour. In modern times, signed integers are always represented in two's complement form, which has many advantages. An interesting thing to note is that it is possible to force gcc and clang to view signed overflow as defined (wraparound, like unsigned), by passing the -fwrapv flag . This is, unfortunately, non-standard. What does this mean, defined vs. undefined? If an unsigned integer overflows, it wraps around back to zero (it's modulo addition). Yet, if a signed integer overflows, $deity only knows what will happen. More specifically: we know what would happen if a two's complement signed integer would overflow, but the compiler can do whatever it wants, because the standard says it is undefined . As a consequence, an optimizing compiler will often assume that a signed integer cannot overflow and optimize out some if-branches or comparisons . This behavior can cause loops to run forever. Note that if the conditions are not written carefully, even the well-defined wraparound overflow of unsigned integers can cause non-terminating loops, (U)INTX_MAX/MIN are your friends. Thus it would seem that unsigned arithmetic is superior, because it has defined over- and underflow. But that's not always true. There's a good reason why many languages (like Java) don't expose unsigned types: they can cause difficult to spot errors. The most common form of under/overflow is underflow in unsigned arithmetic . Subtracting 1 from unsigned int num = 0; will make it wrap around to UINT_MAX . This is much more common than one would think . For this reason alone, it is usually much safer to use a plain int as a loop counter instead of uint32_t / size_t /... or another unsigned type. Even seasoned programmers find it difficult to avoid writing unsigned code that doesn't underflow in some cases. Problem : correct signed code is easier to write, but you have to use casts when comparing to size_t (which happens often, as it is the return type of sizeof , strlen and many others). Casts are ugly and should be avoided if at all possible. But we cannot avoid them everywhere. Sometimes, a trade-off has to be made. See previous -Wconversion PRs for examples. Conclusion : if there is any chance of underflow or the loop in question is small (definitely less than 2^31 items), use signed arithmetic and a guard before the loop. if there is any chance of overflow, use unsigned arithmetic and possibly guards. if there is a chance of both underflow and overflow, be extremely careful and paranoid (guards/asserts). Guarded casting Fixed-size vs. generic types Should we use (u)intX_t and friends over char , short , int , long et al.? ... size_t : ... rsize_t : this type is new in the C11 standard, which is why we can't use it, but the reasoning and usage behind it are interesting . Instead of RSIZE_MAX being the actual maximum value that a variable of type rsize_t can have, it is less than that. This means that one can check if val <= RSIZE_MAX before continuing operations and have it be useful. The first useful property is: values about RSIZE_MAX are usually too large to be useful anyway. Who wants to allocate such titanic amounts of memory anyway, if rsize_t is 64-bits? Arguably it would be better to refuse to perform the operation. The second useful property is nice to make unsigned arithmetic less susceptible to the dreaded underflow problem. rsize_t val = -4 will be larger than RSIZE_MAX because it has wrapped around. Any functions that does a bounds-check on RSIZE_MAX will reject that value. This seems to be a good way to interact with unsigned code without needing to cast ( rsize_t should be unsigned) and still have the safety advantages of signed arithmetic. Tools and articles Secure C Coding Modern source-to-source transformation with Clang and libTooling How Should You Write a Fast Integer Overflow Check? Stubborn and ignorant use of int where size_t is needed Undefined behavior https://cryptoservices.github.io/fde/2018/11/30/undefined-behavior.html","title":"C-programming"},{"location":"C-programming/#c-programming-techniques-and-neovim-specific-guidance","text":"","title":"C programming techniques and Neovim-specific guidance"},{"location":"C-programming/#sizeof","text":"sizeof(<var>) vs sizeof(<type>) something you have to be really careful about: the difference between arrays and pointers [...] be judicious: if the variable is simple (int, long, ...), use sizeof(variable) , if the variable is complex (struct, pointer-to-pointer, ...), use sizeof(the_actual_type) .","title":"sizeof"},{"location":"C-programming/#scope","text":"It is undefined behavior to access a pointer that was assigned in an inner scope .","title":"Scope"},{"location":"C-programming/#struct-organization","text":"https://github.com/neovim/neovim/pull/656#issuecomment-41905534 TODO: link to discussion of legacy Vim struct hack","title":"Struct organization"},{"location":"C-programming/#unsigned-or-signed-integer-overflowunderflow","text":"Conversion of signed variables to unsigned (in files not checked by -Wconversion ) There are a few very important things to keep in mind while choosing between signed and unsigned integral types: Firstly, unsigned overflow is defined , while signed overflow is not . This is an unfortunate historical oversight stemming from a time where it wasn't sure what representation a signed integer would have . The C standard decided that it shouldn't/couldn't specify what would happen when a signed integer overflows, because each representation would have different behaviour. In modern times, signed integers are always represented in two's complement form, which has many advantages. An interesting thing to note is that it is possible to force gcc and clang to view signed overflow as defined (wraparound, like unsigned), by passing the -fwrapv flag . This is, unfortunately, non-standard. What does this mean, defined vs. undefined? If an unsigned integer overflows, it wraps around back to zero (it's modulo addition). Yet, if a signed integer overflows, $deity only knows what will happen. More specifically: we know what would happen if a two's complement signed integer would overflow, but the compiler can do whatever it wants, because the standard says it is undefined . As a consequence, an optimizing compiler will often assume that a signed integer cannot overflow and optimize out some if-branches or comparisons . This behavior can cause loops to run forever. Note that if the conditions are not written carefully, even the well-defined wraparound overflow of unsigned integers can cause non-terminating loops, (U)INTX_MAX/MIN are your friends. Thus it would seem that unsigned arithmetic is superior, because it has defined over- and underflow. But that's not always true. There's a good reason why many languages (like Java) don't expose unsigned types: they can cause difficult to spot errors. The most common form of under/overflow is underflow in unsigned arithmetic . Subtracting 1 from unsigned int num = 0; will make it wrap around to UINT_MAX . This is much more common than one would think . For this reason alone, it is usually much safer to use a plain int as a loop counter instead of uint32_t / size_t /... or another unsigned type. Even seasoned programmers find it difficult to avoid writing unsigned code that doesn't underflow in some cases. Problem : correct signed code is easier to write, but you have to use casts when comparing to size_t (which happens often, as it is the return type of sizeof , strlen and many others). Casts are ugly and should be avoided if at all possible. But we cannot avoid them everywhere. Sometimes, a trade-off has to be made. See previous -Wconversion PRs for examples. Conclusion : if there is any chance of underflow or the loop in question is small (definitely less than 2^31 items), use signed arithmetic and a guard before the loop. if there is any chance of overflow, use unsigned arithmetic and possibly guards. if there is a chance of both underflow and overflow, be extremely careful and paranoid (guards/asserts).","title":"Unsigned or signed? Integer overflow/underflow"},{"location":"C-programming/#guarded-casting","text":"","title":"Guarded casting"},{"location":"C-programming/#fixed-size-vs-generic-types","text":"Should we use (u)intX_t and friends over char , short , int , long et al.? ... size_t : ... rsize_t : this type is new in the C11 standard, which is why we can't use it, but the reasoning and usage behind it are interesting . Instead of RSIZE_MAX being the actual maximum value that a variable of type rsize_t can have, it is less than that. This means that one can check if val <= RSIZE_MAX before continuing operations and have it be useful. The first useful property is: values about RSIZE_MAX are usually too large to be useful anyway. Who wants to allocate such titanic amounts of memory anyway, if rsize_t is 64-bits? Arguably it would be better to refuse to perform the operation. The second useful property is nice to make unsigned arithmetic less susceptible to the dreaded underflow problem. rsize_t val = -4 will be larger than RSIZE_MAX because it has wrapped around. Any functions that does a bounds-check on RSIZE_MAX will reject that value. This seems to be a good way to interact with unsigned code without needing to cast ( rsize_t should be unsigned) and still have the safety advantages of signed arithmetic.","title":"Fixed-size vs. generic types"},{"location":"C-programming/#tools-and-articles","text":"Secure C Coding Modern source-to-source transformation with Clang and libTooling How Should You Write a Fast Integer Overflow Check? Stubborn and ignorant use of int where size_t is needed","title":"Tools and articles"},{"location":"C-programming/#undefined-behavior","text":"https://cryptoservices.github.io/fde/2018/11/30/undefined-behavior.html","title":"Undefined behavior"},{"location":"Code-overview/","text":"Here are a few hints for finding your way around the source code. This doesn't make it less complex than it is, but it gets you started. Jumping around Use ctags -R to generate a tags file for the :tag command. (We recommend universal-ctags instead of the default ctags provided by most distros; see also Development-tips .) To jump to a function or variable definition, move the cursor on the name and use the CTRL-] command. Use CTRL-T or CTRL-O to jump back. To jump to a file, move the cursor on its name and use the gf command. Most code can be found in a file with an obvious name (incomplete list): * buffer.c manipulating buffers (loaded files) * diff.c diff mode (vimdiff) * eval.c expression evaluation * fileio.c reading and writing files * fold.c folding * getchar.c getting characters and key mapping * mark.c marks * mbyte.c multi-byte character handling * memfile.c storing lines for buffers in a swapfile * memline.c storing lines for buffers in memory * menu.c menus * message.c (error) messages * ops.c handling operators ( d , y , p ) * option.c options * quickfix.c quickfix commands ( :make , :cn ) * regexp.c pattern matching * screen.c updating the windows * search.c pattern searching * spell.c spell checking * syntax.c syntax and other highlighting * tag.c tags * terminal.c integrated terminal emulator * undo.c undo and redo * window.c handling split windows Important variables The current mode is stored in State . The values it can have are NORMAL , INSERT , CMDLINE , and a few others. The current window is curwin . The current buffer is curbuf . These point to structures with the cursor position in the window, option values, the file name, etc. All the global variables are declared in globals.h . The main loop This is conveniently called main_loop() . It updates a few things and then calls normal_cmd() to process a command. This returns when the command is finished. The basic idea is that Vim waits for the user to type a character and processes it until another character is needed. Thus there are several places where Vim waits for a character to be typed. The vgetc() function is used for this. It also handles mapping. Updating the screen is mostly postponed until a command or a sequence of commands has finished. The work is done by update_screen() , which calls win_update() for every window, which calls win_line() for every line. See the start of screen.c for more explanations. Command-line mode When typing a : , normal_cmd() will call getcmdline() to obtain a line with an Ex command. getcmdline() contains a loop that will handle each typed character. It returns when hitting <CR> or <Esc> or some other character that ends the command line mode. Ex commands Ex commands are handled by the function do_cmdline() . It does the generic parsing of the : command line and calls do_one_cmd() for each separate command. It also takes care of while loops. do_one_cmd() parses the range and generic arguments and puts them in the exarg_t and passes it to the function that handles the command. The : commands are listed in ex_cmds_defs.h . The third entry of each item is the name of the function that handles the command. The last entry are the flags that are used for the command. Normal mode commands The Normal mode commands are handled by the normal_cmd() function. It also handles the optional count and an extra character for some commands. These are passed in a cmdarg_t to the function that handles the command. There is a table nv_cmds in normal.c which lists the first character of every command. The second entry of each item is the name of the function that handles the command. Insert mode commands When doing an i or a command, normal_cmd() will call the edit() function. It contains a loop that waits for the next character and handles it. It returns when leaving Insert mode. Options There is a list with all option names in option.c , called options[] . Code Overview (Visualization)","title":"Code-overview"},{"location":"Code-overview/#jumping-around","text":"Use ctags -R to generate a tags file for the :tag command. (We recommend universal-ctags instead of the default ctags provided by most distros; see also Development-tips .) To jump to a function or variable definition, move the cursor on the name and use the CTRL-] command. Use CTRL-T or CTRL-O to jump back. To jump to a file, move the cursor on its name and use the gf command. Most code can be found in a file with an obvious name (incomplete list): * buffer.c manipulating buffers (loaded files) * diff.c diff mode (vimdiff) * eval.c expression evaluation * fileio.c reading and writing files * fold.c folding * getchar.c getting characters and key mapping * mark.c marks * mbyte.c multi-byte character handling * memfile.c storing lines for buffers in a swapfile * memline.c storing lines for buffers in memory * menu.c menus * message.c (error) messages * ops.c handling operators ( d , y , p ) * option.c options * quickfix.c quickfix commands ( :make , :cn ) * regexp.c pattern matching * screen.c updating the windows * search.c pattern searching * spell.c spell checking * syntax.c syntax and other highlighting * tag.c tags * terminal.c integrated terminal emulator * undo.c undo and redo * window.c handling split windows","title":"Jumping around"},{"location":"Code-overview/#important-variables","text":"The current mode is stored in State . The values it can have are NORMAL , INSERT , CMDLINE , and a few others. The current window is curwin . The current buffer is curbuf . These point to structures with the cursor position in the window, option values, the file name, etc. All the global variables are declared in globals.h .","title":"Important variables"},{"location":"Code-overview/#the-main-loop","text":"This is conveniently called main_loop() . It updates a few things and then calls normal_cmd() to process a command. This returns when the command is finished. The basic idea is that Vim waits for the user to type a character and processes it until another character is needed. Thus there are several places where Vim waits for a character to be typed. The vgetc() function is used for this. It also handles mapping. Updating the screen is mostly postponed until a command or a sequence of commands has finished. The work is done by update_screen() , which calls win_update() for every window, which calls win_line() for every line. See the start of screen.c for more explanations.","title":"The main loop"},{"location":"Code-overview/#command-line-mode","text":"When typing a : , normal_cmd() will call getcmdline() to obtain a line with an Ex command. getcmdline() contains a loop that will handle each typed character. It returns when hitting <CR> or <Esc> or some other character that ends the command line mode.","title":"Command-line mode"},{"location":"Code-overview/#ex-commands","text":"Ex commands are handled by the function do_cmdline() . It does the generic parsing of the : command line and calls do_one_cmd() for each separate command. It also takes care of while loops. do_one_cmd() parses the range and generic arguments and puts them in the exarg_t and passes it to the function that handles the command. The : commands are listed in ex_cmds_defs.h . The third entry of each item is the name of the function that handles the command. The last entry are the flags that are used for the command.","title":"Ex commands"},{"location":"Code-overview/#normal-mode-commands","text":"The Normal mode commands are handled by the normal_cmd() function. It also handles the optional count and an extra character for some commands. These are passed in a cmdarg_t to the function that handles the command. There is a table nv_cmds in normal.c which lists the first character of every command. The second entry of each item is the name of the function that handles the command.","title":"Normal mode commands"},{"location":"Code-overview/#insert-mode-commands","text":"When doing an i or a command, normal_cmd() will call the edit() function. It contains a loop that waits for the next character and handles it. It returns when leaving Insert mode.","title":"Insert mode commands"},{"location":"Code-overview/#options","text":"There is a list with all option names in option.c , called options[] .","title":"Options"},{"location":"Code-overview/#code-overview-visualization","text":"","title":"Code Overview (Visualization)"},{"location":"Code-review-checklist/","text":"Many items were taken from here and here . Code Are CI builds passing? If no, why? Is the code easily understood? Does the code work? Does it perform its intended function, the logic is correct, etc? Does the error handling work? Is memory usage acceptable, even with large inputs? Is code covered by functional or unit tests? Are error paths covered by functional or unit tests? All errors which are relatively easy to check must be checked: error conditions like \u201copen() failed after stat() was successfull\u201d or \u201carray size greater then INT_MAX\u201d may be ignored for being just as unlikely as uneasy to test, but otherwise having bugs in code which does error handling is way too common to be ignored. For new code, are unit tests written where needed? Are invalid parameter values handled where needed? Can any global/static variables be replaced? Are variables/functions named intuitively? Can any function attributes be used? Is there any redundant or duplicate code? Is the code modular enough? Can any of the code be replaced with library functions? Do loops have a set length and correct termination conditions? Can any logging or debugging code be removed? Are there any unneeded assert statements? Does the code conform to the style guide ? Optimization that makes code harder to read should only be implemented if a profiler or other tool has indicated that the routine stands to gain from optimization. These kinds of optimizations should be well-documented and code that performs the same task simply should be preserved somewhere. Are return values being checked? Are there any use after frees? Are there any resource leaks? Memory leaks, unclosed sockets, etc. Are there any null pointer dereferences? Are any uninitialized variables used? Are there any cases of possible arithmetic overflow? Documentation Are there any superfluous comments? Where needed, do comments exist and describe the intent of the code? Are any comments made outdated by the new code? Is any unusual behavior or edge-case handling described? Are complex algorithms explained and justified? Is code that depends on non-obvious behavior in external libraries documented with reference to external documentation? Is the use and function of API functions documented? Are data structures/typedefs explained? Is there any incomplete code, e.g., code marked TODO , FIXME , or XXX ?","title":"Code-review-checklist"},{"location":"Code-review-checklist/#code","text":"Are CI builds passing? If no, why? Is the code easily understood? Does the code work? Does it perform its intended function, the logic is correct, etc? Does the error handling work? Is memory usage acceptable, even with large inputs? Is code covered by functional or unit tests? Are error paths covered by functional or unit tests? All errors which are relatively easy to check must be checked: error conditions like \u201copen() failed after stat() was successfull\u201d or \u201carray size greater then INT_MAX\u201d may be ignored for being just as unlikely as uneasy to test, but otherwise having bugs in code which does error handling is way too common to be ignored. For new code, are unit tests written where needed? Are invalid parameter values handled where needed? Can any global/static variables be replaced? Are variables/functions named intuitively? Can any function attributes be used? Is there any redundant or duplicate code? Is the code modular enough? Can any of the code be replaced with library functions? Do loops have a set length and correct termination conditions? Can any logging or debugging code be removed? Are there any unneeded assert statements? Does the code conform to the style guide ? Optimization that makes code harder to read should only be implemented if a profiler or other tool has indicated that the routine stands to gain from optimization. These kinds of optimizations should be well-documented and code that performs the same task simply should be preserved somewhere. Are return values being checked? Are there any use after frees? Are there any resource leaks? Memory leaks, unclosed sockets, etc. Are there any null pointer dereferences? Are any uninitialized variables used? Are there any cases of possible arithmetic overflow?","title":"Code"},{"location":"Code-review-checklist/#documentation","text":"Are there any superfluous comments? Where needed, do comments exist and describe the intent of the code? Are any comments made outdated by the new code? Is any unusual behavior or edge-case handling described? Are complex algorithms explained and justified? Is code that depends on non-obvious behavior in external libraries documented with reference to external documentation? Is the use and function of API functions documented? Are data structures/typedefs explained? Is there any incomplete code, e.g., code marked TODO , FIXME , or XXX ?","title":"Documentation"},{"location":"Contributing/","text":"This page was merged with CONTRIBUTING.md . Please link to that document instead of this wiki page.","title":"Contributing"},{"location":"Deps/","text":"Dependencies Forks For some dependencies we maintain temporary \"forks\", which are simply private branches with a few extra patches, while we wait for the upstream project to merge the patches. This is done instead of maintaining the patches as (fragile) CMake PATCH_COMMAND steps. For Windows OS some of these patches are required. For all other cases, Nvim builds against and supports both the \"vanilla\" dependency (without Nvim's patches) and typically much older versions. The complete, current list of forked dependencies is as follows: https://github.com/neovim/libuv Neovim fork lives on the nvim branch: https://github.com/neovim/libuv/compare/v1.x...nvim https://github.com/neovim/libvterm Neovim fork lives on the nvim branch: https://github.com/neovim/libvterm/compare/master...nvim https://github.com/neovim/libtermkey https://github.com/neovim/unibilium The original project was abandoned , so the neovim/unibilium fork is considered \"upstream\" and is maintained on the master branch.","title":"Deps"},{"location":"Deps/#dependencies","text":"","title":"Dependencies"},{"location":"Deps/#forks","text":"For some dependencies we maintain temporary \"forks\", which are simply private branches with a few extra patches, while we wait for the upstream project to merge the patches. This is done instead of maintaining the patches as (fragile) CMake PATCH_COMMAND steps. For Windows OS some of these patches are required. For all other cases, Nvim builds against and supports both the \"vanilla\" dependency (without Nvim's patches) and typically much older versions. The complete, current list of forked dependencies is as follows: https://github.com/neovim/libuv Neovim fork lives on the nvim branch: https://github.com/neovim/libuv/compare/v1.x...nvim https://github.com/neovim/libvterm Neovim fork lives on the nvim branch: https://github.com/neovim/libvterm/compare/master...nvim https://github.com/neovim/libtermkey https://github.com/neovim/unibilium The original project was abandoned , so the neovim/unibilium fork is considered \"upstream\" and is maintained on the master branch.","title":"Forks"},{"location":"Development-tips/","text":"This page was migrated to the FAQ and CONTRIBUTING.md documents. Please update (or report) the link that took you here! Developer info lives in one of three places: :help dev (long-lived, highly relevant info) CONTRIBUTING.md (highly relevant to new contributors) FAQ (transient/highly-specific info)","title":"Development-tips"},{"location":"FAQ/","text":"To start Neovim, run nvim (not neovim ). If something broke after upgrading, check Following-HEAD . :checkhealth detects and resolves many of the problems in this FAQ. Try it! Where should I put my config ( vimrc )? See :help vimrc . You can copy your existing vimrc, or symlink to it. :help nvim-from-vim How stable is the development (pre-release) version? The unstable (pre-release) version of Neovim (\"HEAD\", i.e. the master branch) is used to aggressively stage new features and changes. It's usually stable, but will occasionally break your workflow. We depend on HEAD users to report \"blind spots\" that were not caught by automated tests. Use the stable (release) version for a more predictable experience. Can I use Ruby-based Vim plugins (e.g. LustyExplorer )? Yes, starting with Neovim 0.1.5 PR #4980 the legacy Vim if_ruby interface is supported. Can I use Lua-based Vim plugins (e.g. neocomplete )? No. Starting with Neovim 0.2 PR #4411 Lua is built-in, but the legacy Vim if_lua interface is not supported. How can I use \"true color\" in the terminal? Add this to your init.vim : set termguicolors See this gist for more information. See this thread for guidance on how to check your system capabilities. Nvim shows weird symbols ( \ufffd[2 q ) when changing modes This is a bug in your terminal emulator. It happens because Nvim sends cursor-shape termcodes by default, if the terminal appears to be xterm-compatible ( TERM=xterm-256color ). To workaround the issue, you can: Use a different terminal emulator Disable guicursor in your Nvim config: :set guicursor= \" Workaround some broken plugins which set guicursor indiscriminately. :autocmd OptionSet guicursor noautocmd set guicursor= See also :help $TERM for recommended values of $TERM . How to change cursor shape in the terminal? For Nvim 0.1.7 or older: see the note about NVIM_TUI_ENABLE_CURSOR_SHAPE in man nvim . For Nvim 0.2 or newer: cursor styling is controlled by the guicursor option. To disable cursor-styling, set guicursor to empty: :set guicursor= \" Workaround some broken plugins which set guicursor indiscriminately. :autocmd OptionSet guicursor noautocmd set guicursor= If you want a non-blinking cursor, use blinkon0 . See :help 'guicursor' . guicursor is enabled by default, unless Nvim thinks your terminal doesn't support it. If you're sure that your terminal supports cursor-shaping, set guicursor in your init.vim, as described in :help 'guicursor' . The Vim terminal options t_SI and t_EI are ignored, like all other t_XX options. Old versions of libvte (gnome-terminal, roxterm, terminator, ...) do not support cursor style control codes. #2537 How to change cursor color in the terminal? Cursor styling (shape, color, behavior) is controlled by guicursor , even in the terminal. Cursor color (as opposed to shape) only works if termguicolors is set. :help 'guicursor' gives an example, but here's a more complicated example which sets different colors in insert-mode and normal-mode: : set termguicolors : hi Cursor guifg = green guibg = green : hi Cursor2 guifg = red guibg = red : set guicursor = n - v - c :block - Cursor /lCursor,i-ci-ve:ver25-Cursor2/ lCursor2 , r - cr :hor20 , o :hor50 Cursor style isn't restored after exiting Nvim Terminals do not provide a way to query the cursor style. Use a VimLeave autocommand to set the cursor style when Nvim exits: au VimLeave * set guicursor=a:block-blinkon0 Cursor shape doesn't change in tmux tmux decides that, not Nvim. See :help tui-cursor-shape for a fix. See #3165 for discussion. Is Windows supported? Yes, starting with the 0.2 release . See the Install page. How to use the Windows clipboard from WSL? To use the Windows clipboard from within WSL, Neovim has to be installed on both Windows and WSL. The win32yank.exe provided by the Neovim Windows installation has to be symlinked to a directory included in your $PATH so it can be found by Neovim on WSL. Replace $NEOVIM_WIN_DIR with the path to your Neovim Windows installation, e.g. /mnt/c/Program Files/Neovim . The command can then be symlinked using: sudo ln -s \"$NEOVIM_WIN_DIR/bin/win32yank.exe\" \"/usr/local/bin/win32yank.exe\" Also, don't forget to set your clipboard to unnamedplus using set clipboard=unnamedplus to make Neovim use the system's clipboard (now Windows' clipboard) by default. See #6227 for more information. What happened to --remote and friends? The code for that family of command-line arguments was removed. It may eventually be reimplemented using the Neovim API, but until then neovim-remote can be used instead. See #1750 for more information. Runtime issues Copying to X11 primary selection with the mouse doesn't work clipboard=autoselect is not implemented yet . You may find this partial workaround to be useful: vnoremap <LeftRelease> \"*ygv Note that this is only a partial workaround. It doesn't work for double-click (word selection) nor triple-click (line selection). But it's better than nothing. My CTRL-H mapping doesn't work This was fixed in Neovim 0.2 . If you are running Neovim 0.1.7 or older , adjust your terminal's \"kbs\" (key_backspace) terminfo entry: infocmp $TERM | sed 's/kbs=^[hH]/kbs=\\\\177/' > $TERM.ti tic $TERM.ti (Feel free to delete the temporary *.ti file created after running the above commands). <Home> or some other \"special\" key doesn't work Make sure $TERM is set correctly. For screen or tmux, TERM should be screen-256color ( Not xterm-256color ) In other cases if \"256\" does not appear in the string it's probably wrong. Try TERM=xterm-256color . :! and system() do weird things with interactive processes Interactive commands are supported by :terminal in Neovim. But :! and system() do not support interactive commands, primarily because Neovim UIs use stdio for msgpack communication, but also for performance, reliability, and consistency across platforms (see :help gui-pty ). See also #1496 and #8217 . Python support isn't working Run :checkhealth in Nvim for automatic diagnosis. Other hints: The python neovim module was renamed to pynvim . See Following-HEAD . If you're using pyenv or virtualenv for the pynvim module , you must set g:python_host_prog and/or g:python3_host_prog to the virtualenv's interpreter path. Read :help provider-python . Be sure you have the latest version of the pynvim Python module: python -m pip install setuptools python -m pip install --upgrade pynvim python2 -m pip install --upgrade pynvim python3 -m pip install --upgrade pynvim Try with nvim -u NORC to make sure your config ( init.vim ) isn't causing a problem. If you get E117: Unknown function , that means Neovim can't find its runtime . :checkhealth reports E5009: Invalid $VIMRUNTIME This means health#check() couldn't load, which suggests that $VIMRUNTIME or &runtimepath is broken. $VIMRUNTIME must point to Neovim's runtime files, not Vim's. The $VIMRUNTIME directory contents should be readable by the current user. Verify that :echo &runtimepath contains the $VIMRUNTIME path. Check the output of: :call health#check() :verbose func health#check Neovim can't find its runtime This is the case if :help nvim shows E149: Sorry, no help for nvim . Make sure that $VIM and $VIMRUNTIME point to Neovim's (as opposed to Vim's) runtime by checking :echo $VIM and :echo $VIMRUNTIME . This should give something like /usr/share/nvim resp. /usr/share/nvim/runtime . Also make sure that you don't accidentally overwrite your runtimepath ( :set runtimepath? ), which includes the above $VIMRUNTIME by default (see :help 'runtimepath' ). E518: Unknown option: [option] Some very old/unnecessary options have been removed from Neovim. See :help nvim-features-removed for the complete list. Neovim is slow Use a fast terminal emulator kitty alacritty Use an optimized build :checkhealth nvim should report one of these \"build types\": Build type: RelWithDebInfo Build type: MinSizeRel Build type: Release If it reports Build type: Debug and you're building Neovim from source, see Building Neovim#optimized-builds . Colors aren't displayed correctly Ensure that $TERM is set correctly. See [:help TERM](https://neovim.io/doc/user/term.html# TERM](https://neovim.io/doc/user/term.html# TERM) for recommended values. From a shell, run TERM=xterm-256color nvim . If colors are displayed correctly, then export that value of TERM in your user profile (usually ~/.profile ): export TERM=xterm-256color If you're using tmux , instead add this to your tmux.conf : set -g default-terminal \"tmux-256color\" For GNU screen , configure your .screenrc : term screen-256color Note: Neovim ignores t_Co and other terminal codes. Neovim can't read UTF-8 characters Run the following from the command line: locale | grep -E '(LANG|LC_CTYPE|LC_ALL)=(.*\\.)?(UTF|utf)-?8' If there's no results, then you might not be using a UTF-8 locale. See the following issues: #1601 #1858 #2386 ESC in tmux or GNU Screen is delayed This is a common problem in tmux / screen (see also tmux/#131 ). The corresponding timeout needs to be tweaked to a low value (10-20ms). .tmux.conf : set -g escape-time 10 # Or for tmux >= 2.6 set -sg escape-time 10 .screenrc : maptimeout 10 \"Why doesn't this happen in Vim?\" It does happen (try vim -N -u NONE ), but if you hit a key quickly after ESC then Vim interprets the ESC as ESC instead of ALT (META). You won't notice the delay unless you closely observe the cursor. The tradeoff is that Vim won't understand ALT (META) key-chords, so for example nnoremap <M-a> won't work. ALT (META) key-chords always work in Nvim. See also :help xterm-cursor-keys in Vim. Nvim 0.3 mimics the Vim behavior while still fully supporting ALT mappings. See :help i_ALT . Installation issues Generating helptags failed If re-installation fails with Generating helptags failed , try removing the previously installed runtime directory (if CMAKE_INSTALL_PREFIX is not set during building, the default is /usr/local/share/nvim ): # rm -r /usr/local/share/nvim Build issues General build issues Run make distclean && make to rule out a stale build environment causing the failure. Proxy issues #2482 If your machine is behind a network proxy and you see this error: Error: Failed installing dependency: https://rocks.moonscript.org/penlight-1.3.2-2.rockspec Error fetching file: Failed downloading http://stevedonovan.github.io/files/penlight-1.3.2-core.zip this can be fixed by setting the https_proxy environment variable (for cURL) . Settings in local.mk don't take effect CMake caches build settings, so you might need to run rm -r build && make after modifying local.mk . CMake errors configure_file Problem configuring file This is probably a permissions issue, which can happen if you run make as the root user, then later run an unprivileged make . To fix this, run rm -rf build and try again. A suitable Lua interpreter was not found. This can be caused by a local LuaRocks installation. Try unsetting the LUA_PATH and LUA_CPATH environment variables (via unset ) before building. Lua packages The Lua packages required by the build process should be automatically installed by LuaRocks (invoked by CMake automatically). If that fails, it could mean: The LuaRocks servers are down. Your network is down. unzip isn't found. In that case LuaRocks will report something like this: Warning: Failed searching manifest: Failed loading manifest: Failed extracting manifest file . The $CDPATH environment variable is interfering with the build, so it should be unset prior to running make . To try a different LuaRocks mirror, create the file .deps/usr/etc/luarocks/config-5.1.lua with these contents: rocks_servers={ \"http://luarocks.giga.puc-rio.br/\" } Then run make cmake . Anaconda error Error message: anaconda3/bin/x86_64-conda_cos6-linux-gnu-cc: not found Solution: conda install gxx_linux-64 Develop Plugins nvimdev.nvim : Neomake integration with Lua/C + Neovim codebase helpful.vim : get the version of Vim/Neovim where a feature was introduced. Neomake : Async linting deoplete.nvim : auto-completion deoplete-clang2 : clang2 completion support for deoplete.nvim coc.nvim : auto-completion, code navigation Tools hererocks (very similar to Python's virtualenv ) is useful for installing Luarocks, LuaJIT, and Lua: curl -LO https://raw.githubusercontent.com/mpeterv/hererocks/latest/hererocks.py chmod u+x hererocks.py # Install LuaJit and LuaRocks 3.0 to the \"myenv\" directory. ./hererocks.py myenv --luajit latest -r3.0 croissant is a Lua REPL Debug Backtrace (Linux) Core dumps are disabled by default on Ubuntu , CentOS and others. To enable core dumps: ulimit -c unlimited On systemd-based systems getting a backtrace is as easy as: coredumpctl -1 gdb It's an optional tool, so you may need to install it: sudo apt install systemd-coredump The full backtrace is most useful, send us the bt.txt file: 2>&1 coredumpctl -1 gdb | tee -a bt.txt thread apply all bt full On older systems a core file will appear in the current directory. To get a backtrace from the core file: gdb build/bin/nvim core 2>&1 | tee backtrace.txt thread apply all bt full Backtrace (macOS / OSX) If nvim crashes, you can see the backtrace in Console.app (under \"Crash Reports\" or \"User Diagnostic Reports\" for older macOS versions). open -a Console You may also want to enable core dumps on macOS . The /cores/ directory must exist and be writable. Using gdb to step through functional tests Use TEST_TAG to run tests matching busted tags (of the form #foo e.g. it(\"test #foo ...\", ...) ): GDB=1 TEST_TAG=foo make functionaltest Then, in another terminal: gdb build/bin/nvim target remote localhost:7777 See also test/functional/helpers.lua . Using lldb to step through unit tests lldb .deps/usr/bin/luajit -- .deps/usr/bin/busted --lpath=\"./build/?.lua\" test/unit/ Using gdb To attach to a running nvim process with a pid of 1234: gdb -tui -p 1234 build/bin/nvim The gdb interactive prompt will appear. At any time you can: break foo to set a breakpoint on the foo() function n to step over the next statement <Enter> to repeat the last command s to step into the next statement c to continue finish to step out of the current function p zub to print the value of zub bt to see a backtrace (callstack) from the current location CTRL-x CTRL-a or tui enable to show a TUI view of the source file in the current debugging context. This can be extremely useful as it avoids the need for a gdb \"frontend\". <up> and <down> to scroll the source file view gdb \"reverse debugging\" set record full insn-number-max unlimited continue for a bit (at least until main() is executed record provoke the bug, then use revert-next , reverse-step , etc. to rewind the debugger Using gdbserver You may want to connect multiple gdb clients to the same running nvim process, or you may want to connect to a remote nvim process with a local gdb . Using gdbserver , you can attach to a single process and control it from multiple gdb clients. Open a terminal and start gdbserver attached to nvim like this: gdbserver :6666 build/bin/nvim 2> gdbserver.log gdbserver is now listening on port 6666. You then need to attach to this debugging session in another terminal: gdb build/bin/nvim Once you've entered gdb , you need to attach to the remote session: target remote localhost:6666 In case gdbserver puts the TUI as a background process, the TUI can become unable to read input from pty (and receives SIGTTIN signal) and/or output data (SIGTTOU signal). To force the TUI as the foreground process, you can add signal (SIGTTOU, SIG_IGN); if (!tcsetpgrp(data->input.in_fd, getpid())) { perror(\"tcsetpgrp failed\"); } to tui.c:terminfo_start. Using gdbserver in tmux Consider using a custom makefile to quickly start debugging sessions using the gdbserver method mentioned above. This example local.mk will create the debugging session when you type make debug . .PHONY : dbg - start dbg - attach debug build build : @ $( MAKE ) nvim dbg-start : build @tmux new-window -n 'dbg-neovim' 'gdbserver :6666 ./build/bin/nvim -D' dbg-attach : @tmux new-window -n 'dbg-cgdb' 'cgdb -x gdb_start.sh ./build/bin/nvim' debug : dbg - start dbg - attach Here gdb_start.sh includes gdb commands to be called when the debugger starts. It needs to attach to the server started by the dbg-start rule. For example: target remote localhost:6666 br main Log file location Nvim's low-level logs are written to ~/.local/share/nvim/log (usually; see :help $NVIM_LOG_FILE ). Debug builds write INFO-level messages to this log file. You can specify the location with the $NVIM_LOG_FILE environment variable. Non-debug builds only log ERROR-level messages. Design Why not use JSON for RPC? JSON cannot easily/efficiently handle binary data JSON specification is ambiguous: http://seriot.ch/parsing_json.php Why embed Lua instead of X? Lua is a very small language, ideal for embedding. The biggest advantage of Python/Ruby/etc is their huge collection of libraries, but that isn't relevant for Nvim, where Nvim is the \"batteries included\" library: introducing another stdlib would be redundant. Lua 5.1 is a complete language: the syntax is frozen. This is great for backwards compatibility. Nvim also uses Lua internally as an alternative to C. Extra performance is useful there, as opposed to a slow language like Python. LuaJIT is one of the fastest runtimes on the planet. It is at least 10x faster than Python. Python/JS cost more than Lua in terms of size and portability, and there are already numerous Python/JS-based editors. So Python/JS would make Nvim bigger and less portable, in exchange for a non-differentiating feature. See also: Why Lua Redis and scripting The Design of Lua Discussion of JavaScript vs Lua Why Lua 5.1 instead of Lua 5.3+? Lua 5.1 is a different language than 5.3. The Lua org makes breaking changes with every new version, so even if we switched (not upgraded, but switched ) to 5.3 we gain nothing when they create the next new language in 5.4, 5.5, etc. And we would lose LuaJit, which is far more valuable than Lua 5.3+. Lua 5.1 is a complete language. To \"upgrade\" it, add libraries, not syntax. Nvim itself already is a pretty good \"stdlib\" for Lua, and we will continue to grow and enhance it. Changing the rules of Lua gains nothing in this context. Will Neovim translate VimL to Lua, instead of executing VimL directly? Update (2016): PR #243 implements the VimL-to-Lua translator. But it is blocked by technical concerns . Much of the work in that PR was re-used/re-purposed (viz. typval_T / vim_to_object refactor , eval.c refactor ). Are plugin authors encouraged to port their plugins from Vimscript to Lua? Do you plan on supporting Vimscript indefinitely? ( #1152 ) We don't anticipate any reason to deprecate Vimscript, which is a valuable DSL for text-editing tasks. Maintaining Vimscript compatibility is less costly than a mass migration of existing Vim plugins. Porting from Vimscript to Lua just for the heck of it gains nothing. Neovim is emphatically a fork of Vim in order to leverage the work already spent on thousands of Vim plugins, while enabling new types of plugins and integrations.","title":"FAQ"},{"location":"FAQ/#where-should-i-put-my-config-vimrc","text":"See :help vimrc . You can copy your existing vimrc, or symlink to it. :help nvim-from-vim","title":"Where should I put my config (vimrc)?"},{"location":"FAQ/#how-stable-is-the-development-pre-release-version","text":"The unstable (pre-release) version of Neovim (\"HEAD\", i.e. the master branch) is used to aggressively stage new features and changes. It's usually stable, but will occasionally break your workflow. We depend on HEAD users to report \"blind spots\" that were not caught by automated tests. Use the stable (release) version for a more predictable experience.","title":"How stable is the development (pre-release) version?"},{"location":"FAQ/#can-i-use-ruby-based-vim-plugins-eg-lustyexplorer","text":"Yes, starting with Neovim 0.1.5 PR #4980 the legacy Vim if_ruby interface is supported.","title":"Can I use Ruby-based Vim plugins (e.g. LustyExplorer)?"},{"location":"FAQ/#can-i-use-lua-based-vim-plugins-eg-neocomplete","text":"No. Starting with Neovim 0.2 PR #4411 Lua is built-in, but the legacy Vim if_lua interface is not supported.","title":"Can I use Lua-based Vim plugins (e.g. neocomplete)?"},{"location":"FAQ/#how-can-i-use-true-color-in-the-terminal","text":"Add this to your init.vim : set termguicolors See this gist for more information. See this thread for guidance on how to check your system capabilities.","title":"How can I use \"true color\" in the terminal?"},{"location":"FAQ/#nvim-shows-weird-symbols-2-q-when-changing-modes","text":"This is a bug in your terminal emulator. It happens because Nvim sends cursor-shape termcodes by default, if the terminal appears to be xterm-compatible ( TERM=xterm-256color ). To workaround the issue, you can: Use a different terminal emulator Disable guicursor in your Nvim config: :set guicursor= \" Workaround some broken plugins which set guicursor indiscriminately. :autocmd OptionSet guicursor noautocmd set guicursor= See also :help $TERM for recommended values of $TERM .","title":"Nvim shows weird symbols (\ufffd[2 q) when changing modes"},{"location":"FAQ/#how-to-change-cursor-shape-in-the-terminal","text":"For Nvim 0.1.7 or older: see the note about NVIM_TUI_ENABLE_CURSOR_SHAPE in man nvim . For Nvim 0.2 or newer: cursor styling is controlled by the guicursor option. To disable cursor-styling, set guicursor to empty: :set guicursor= \" Workaround some broken plugins which set guicursor indiscriminately. :autocmd OptionSet guicursor noautocmd set guicursor= If you want a non-blinking cursor, use blinkon0 . See :help 'guicursor' . guicursor is enabled by default, unless Nvim thinks your terminal doesn't support it. If you're sure that your terminal supports cursor-shaping, set guicursor in your init.vim, as described in :help 'guicursor' . The Vim terminal options t_SI and t_EI are ignored, like all other t_XX options. Old versions of libvte (gnome-terminal, roxterm, terminator, ...) do not support cursor style control codes. #2537","title":"How to change cursor shape in the terminal?"},{"location":"FAQ/#how-to-change-cursor-color-in-the-terminal","text":"Cursor styling (shape, color, behavior) is controlled by guicursor , even in the terminal. Cursor color (as opposed to shape) only works if termguicolors is set. :help 'guicursor' gives an example, but here's a more complicated example which sets different colors in insert-mode and normal-mode: : set termguicolors : hi Cursor guifg = green guibg = green : hi Cursor2 guifg = red guibg = red : set guicursor = n - v - c :block - Cursor /lCursor,i-ci-ve:ver25-Cursor2/ lCursor2 , r - cr :hor20 , o :hor50","title":"How to change cursor color in the terminal?"},{"location":"FAQ/#cursor-style-isnt-restored-after-exiting-nvim","text":"Terminals do not provide a way to query the cursor style. Use a VimLeave autocommand to set the cursor style when Nvim exits: au VimLeave * set guicursor=a:block-blinkon0","title":"Cursor style isn't restored after exiting Nvim"},{"location":"FAQ/#cursor-shape-doesnt-change-in-tmux","text":"tmux decides that, not Nvim. See :help tui-cursor-shape for a fix. See #3165 for discussion.","title":"Cursor shape doesn't change in tmux"},{"location":"FAQ/#is-windows-supported","text":"Yes, starting with the 0.2 release . See the Install page.","title":"Is Windows supported?"},{"location":"FAQ/#how-to-use-the-windows-clipboard-from-wsl","text":"To use the Windows clipboard from within WSL, Neovim has to be installed on both Windows and WSL. The win32yank.exe provided by the Neovim Windows installation has to be symlinked to a directory included in your $PATH so it can be found by Neovim on WSL. Replace $NEOVIM_WIN_DIR with the path to your Neovim Windows installation, e.g. /mnt/c/Program Files/Neovim . The command can then be symlinked using: sudo ln -s \"$NEOVIM_WIN_DIR/bin/win32yank.exe\" \"/usr/local/bin/win32yank.exe\" Also, don't forget to set your clipboard to unnamedplus using set clipboard=unnamedplus to make Neovim use the system's clipboard (now Windows' clipboard) by default. See #6227 for more information.","title":"How to use the Windows clipboard from WSL?"},{"location":"FAQ/#what-happened-to-remote-and-friends","text":"The code for that family of command-line arguments was removed. It may eventually be reimplemented using the Neovim API, but until then neovim-remote can be used instead. See #1750 for more information.","title":"What happened to --remote and friends?"},{"location":"FAQ/#runtime-issues","text":"","title":"Runtime issues"},{"location":"FAQ/#copying-to-x11-primary-selection-with-the-mouse-doesnt-work","text":"clipboard=autoselect is not implemented yet . You may find this partial workaround to be useful: vnoremap <LeftRelease> \"*ygv Note that this is only a partial workaround. It doesn't work for double-click (word selection) nor triple-click (line selection). But it's better than nothing.","title":"Copying to X11 primary selection with the mouse doesn't work"},{"location":"FAQ/#my-ctrl-h-mapping-doesnt-work","text":"This was fixed in Neovim 0.2 . If you are running Neovim 0.1.7 or older , adjust your terminal's \"kbs\" (key_backspace) terminfo entry: infocmp $TERM | sed 's/kbs=^[hH]/kbs=\\\\177/' > $TERM.ti tic $TERM.ti (Feel free to delete the temporary *.ti file created after running the above commands).","title":"My CTRL-H mapping doesn't work"},{"location":"FAQ/#home-or-some-other-special-key-doesnt-work","text":"Make sure $TERM is set correctly. For screen or tmux, TERM should be screen-256color ( Not xterm-256color ) In other cases if \"256\" does not appear in the string it's probably wrong. Try TERM=xterm-256color .","title":"&lt;Home&gt; or some other \"special\" key doesn't work"},{"location":"FAQ/#and-system-do-weird-things-with-interactive-processes","text":"Interactive commands are supported by :terminal in Neovim. But :! and system() do not support interactive commands, primarily because Neovim UIs use stdio for msgpack communication, but also for performance, reliability, and consistency across platforms (see :help gui-pty ). See also #1496 and #8217 .","title":":! and system() do weird things with interactive processes"},{"location":"FAQ/#python-support-isnt-working","text":"Run :checkhealth in Nvim for automatic diagnosis. Other hints: The python neovim module was renamed to pynvim . See Following-HEAD . If you're using pyenv or virtualenv for the pynvim module , you must set g:python_host_prog and/or g:python3_host_prog to the virtualenv's interpreter path. Read :help provider-python . Be sure you have the latest version of the pynvim Python module: python -m pip install setuptools python -m pip install --upgrade pynvim python2 -m pip install --upgrade pynvim python3 -m pip install --upgrade pynvim Try with nvim -u NORC to make sure your config ( init.vim ) isn't causing a problem. If you get E117: Unknown function , that means Neovim can't find its runtime .","title":"Python support isn't working"},{"location":"FAQ/#checkhealth-reports-e5009-invalid-vimruntime","text":"This means health#check() couldn't load, which suggests that $VIMRUNTIME or &runtimepath is broken. $VIMRUNTIME must point to Neovim's runtime files, not Vim's. The $VIMRUNTIME directory contents should be readable by the current user. Verify that :echo &runtimepath contains the $VIMRUNTIME path. Check the output of: :call health#check() :verbose func health#check","title":":checkhealth reports E5009: Invalid $VIMRUNTIME"},{"location":"FAQ/#neovim-cant-find-its-runtime","text":"This is the case if :help nvim shows E149: Sorry, no help for nvim . Make sure that $VIM and $VIMRUNTIME point to Neovim's (as opposed to Vim's) runtime by checking :echo $VIM and :echo $VIMRUNTIME . This should give something like /usr/share/nvim resp. /usr/share/nvim/runtime . Also make sure that you don't accidentally overwrite your runtimepath ( :set runtimepath? ), which includes the above $VIMRUNTIME by default (see :help 'runtimepath' ).","title":"Neovim can't find its runtime"},{"location":"FAQ/#e518-unknown-option-option","text":"Some very old/unnecessary options have been removed from Neovim. See :help nvim-features-removed for the complete list.","title":"E518: Unknown option: [option]"},{"location":"FAQ/#neovim-is-slow","text":"","title":"Neovim is slow"},{"location":"FAQ/#use-a-fast-terminal-emulator","text":"kitty alacritty","title":"Use a fast terminal emulator"},{"location":"FAQ/#use-an-optimized-build","text":":checkhealth nvim should report one of these \"build types\": Build type: RelWithDebInfo Build type: MinSizeRel Build type: Release If it reports Build type: Debug and you're building Neovim from source, see Building Neovim#optimized-builds .","title":"Use an optimized build"},{"location":"FAQ/#colors-arent-displayed-correctly","text":"Ensure that $TERM is set correctly. See [:help TERM](https://neovim.io/doc/user/term.html# TERM](https://neovim.io/doc/user/term.html# TERM) for recommended values. From a shell, run TERM=xterm-256color nvim . If colors are displayed correctly, then export that value of TERM in your user profile (usually ~/.profile ): export TERM=xterm-256color If you're using tmux , instead add this to your tmux.conf : set -g default-terminal \"tmux-256color\" For GNU screen , configure your .screenrc : term screen-256color Note: Neovim ignores t_Co and other terminal codes.","title":"Colors aren't displayed correctly"},{"location":"FAQ/#neovim-cant-read-utf-8-characters","text":"Run the following from the command line: locale | grep -E '(LANG|LC_CTYPE|LC_ALL)=(.*\\.)?(UTF|utf)-?8' If there's no results, then you might not be using a UTF-8 locale. See the following issues: #1601 #1858 #2386","title":"Neovim can't read UTF-8 characters"},{"location":"FAQ/#esc-in-tmux-or-gnu-screen-is-delayed","text":"This is a common problem in tmux / screen (see also tmux/#131 ). The corresponding timeout needs to be tweaked to a low value (10-20ms). .tmux.conf : set -g escape-time 10 # Or for tmux >= 2.6 set -sg escape-time 10 .screenrc : maptimeout 10","title":"ESC in tmux or GNU Screen is delayed"},{"location":"FAQ/#why-doesnt-this-happen-in-vim","text":"It does happen (try vim -N -u NONE ), but if you hit a key quickly after ESC then Vim interprets the ESC as ESC instead of ALT (META). You won't notice the delay unless you closely observe the cursor. The tradeoff is that Vim won't understand ALT (META) key-chords, so for example nnoremap <M-a> won't work. ALT (META) key-chords always work in Nvim. See also :help xterm-cursor-keys in Vim. Nvim 0.3 mimics the Vim behavior while still fully supporting ALT mappings. See :help i_ALT .","title":"\"Why doesn't this happen in Vim?\""},{"location":"FAQ/#installation-issues","text":"","title":"Installation issues"},{"location":"FAQ/#generating-helptags-failed","text":"If re-installation fails with Generating helptags failed , try removing the previously installed runtime directory (if CMAKE_INSTALL_PREFIX is not set during building, the default is /usr/local/share/nvim ): # rm -r /usr/local/share/nvim","title":"Generating helptags failed"},{"location":"FAQ/#build-issues","text":"","title":"Build issues"},{"location":"FAQ/#general-build-issues","text":"Run make distclean && make to rule out a stale build environment causing the failure.","title":"General build issues"},{"location":"FAQ/#proxy-issues-2482","text":"If your machine is behind a network proxy and you see this error: Error: Failed installing dependency: https://rocks.moonscript.org/penlight-1.3.2-2.rockspec Error fetching file: Failed downloading http://stevedonovan.github.io/files/penlight-1.3.2-core.zip this can be fixed by setting the https_proxy environment variable (for cURL) .","title":"Proxy issues #2482"},{"location":"FAQ/#settings-in-localmk-dont-take-effect","text":"CMake caches build settings, so you might need to run rm -r build && make after modifying local.mk .","title":"Settings in local.mk don't take effect"},{"location":"FAQ/#cmake-errors","text":"configure_file Problem configuring file This is probably a permissions issue, which can happen if you run make as the root user, then later run an unprivileged make . To fix this, run rm -rf build and try again. A suitable Lua interpreter was not found. This can be caused by a local LuaRocks installation. Try unsetting the LUA_PATH and LUA_CPATH environment variables (via unset ) before building.","title":"CMake errors"},{"location":"FAQ/#lua-packages","text":"The Lua packages required by the build process should be automatically installed by LuaRocks (invoked by CMake automatically). If that fails, it could mean: The LuaRocks servers are down. Your network is down. unzip isn't found. In that case LuaRocks will report something like this: Warning: Failed searching manifest: Failed loading manifest: Failed extracting manifest file . The $CDPATH environment variable is interfering with the build, so it should be unset prior to running make . To try a different LuaRocks mirror, create the file .deps/usr/etc/luarocks/config-5.1.lua with these contents: rocks_servers={ \"http://luarocks.giga.puc-rio.br/\" } Then run make cmake .","title":"Lua packages"},{"location":"FAQ/#anaconda-error","text":"Error message: anaconda3/bin/x86_64-conda_cos6-linux-gnu-cc: not found Solution: conda install gxx_linux-64","title":"Anaconda error"},{"location":"FAQ/#develop","text":"","title":"Develop"},{"location":"FAQ/#plugins","text":"nvimdev.nvim : Neomake integration with Lua/C + Neovim codebase helpful.vim : get the version of Vim/Neovim where a feature was introduced. Neomake : Async linting deoplete.nvim : auto-completion deoplete-clang2 : clang2 completion support for deoplete.nvim coc.nvim : auto-completion, code navigation","title":"Plugins"},{"location":"FAQ/#tools","text":"hererocks (very similar to Python's virtualenv ) is useful for installing Luarocks, LuaJIT, and Lua: curl -LO https://raw.githubusercontent.com/mpeterv/hererocks/latest/hererocks.py chmod u+x hererocks.py # Install LuaJit and LuaRocks 3.0 to the \"myenv\" directory. ./hererocks.py myenv --luajit latest -r3.0 croissant is a Lua REPL","title":"Tools"},{"location":"FAQ/#debug","text":"","title":"Debug"},{"location":"FAQ/#backtrace-linux","text":"Core dumps are disabled by default on Ubuntu , CentOS and others. To enable core dumps: ulimit -c unlimited On systemd-based systems getting a backtrace is as easy as: coredumpctl -1 gdb It's an optional tool, so you may need to install it: sudo apt install systemd-coredump The full backtrace is most useful, send us the bt.txt file: 2>&1 coredumpctl -1 gdb | tee -a bt.txt thread apply all bt full On older systems a core file will appear in the current directory. To get a backtrace from the core file: gdb build/bin/nvim core 2>&1 | tee backtrace.txt thread apply all bt full","title":"Backtrace (Linux)"},{"location":"FAQ/#backtrace-macos-osx","text":"If nvim crashes, you can see the backtrace in Console.app (under \"Crash Reports\" or \"User Diagnostic Reports\" for older macOS versions). open -a Console You may also want to enable core dumps on macOS . The /cores/ directory must exist and be writable.","title":"Backtrace (macOS / OSX)"},{"location":"FAQ/#using-gdb-to-step-through-functional-tests","text":"Use TEST_TAG to run tests matching busted tags (of the form #foo e.g. it(\"test #foo ...\", ...) ): GDB=1 TEST_TAG=foo make functionaltest Then, in another terminal: gdb build/bin/nvim target remote localhost:7777 See also test/functional/helpers.lua .","title":"Using gdb to step through functional tests"},{"location":"FAQ/#using-lldb-to-step-through-unit-tests","text":"lldb .deps/usr/bin/luajit -- .deps/usr/bin/busted --lpath=\"./build/?.lua\" test/unit/","title":"Using lldb to step through unit tests"},{"location":"FAQ/#using-gdb","text":"To attach to a running nvim process with a pid of 1234: gdb -tui -p 1234 build/bin/nvim The gdb interactive prompt will appear. At any time you can: break foo to set a breakpoint on the foo() function n to step over the next statement <Enter> to repeat the last command s to step into the next statement c to continue finish to step out of the current function p zub to print the value of zub bt to see a backtrace (callstack) from the current location CTRL-x CTRL-a or tui enable to show a TUI view of the source file in the current debugging context. This can be extremely useful as it avoids the need for a gdb \"frontend\". <up> and <down> to scroll the source file view","title":"Using gdb"},{"location":"FAQ/#gdb-reverse-debugging","text":"set record full insn-number-max unlimited continue for a bit (at least until main() is executed record provoke the bug, then use revert-next , reverse-step , etc. to rewind the debugger","title":"gdb \"reverse debugging\""},{"location":"FAQ/#using-gdbserver","text":"You may want to connect multiple gdb clients to the same running nvim process, or you may want to connect to a remote nvim process with a local gdb . Using gdbserver , you can attach to a single process and control it from multiple gdb clients. Open a terminal and start gdbserver attached to nvim like this: gdbserver :6666 build/bin/nvim 2> gdbserver.log gdbserver is now listening on port 6666. You then need to attach to this debugging session in another terminal: gdb build/bin/nvim Once you've entered gdb , you need to attach to the remote session: target remote localhost:6666 In case gdbserver puts the TUI as a background process, the TUI can become unable to read input from pty (and receives SIGTTIN signal) and/or output data (SIGTTOU signal). To force the TUI as the foreground process, you can add signal (SIGTTOU, SIG_IGN); if (!tcsetpgrp(data->input.in_fd, getpid())) { perror(\"tcsetpgrp failed\"); } to tui.c:terminfo_start.","title":"Using gdbserver"},{"location":"FAQ/#using-gdbserver-in-tmux","text":"Consider using a custom makefile to quickly start debugging sessions using the gdbserver method mentioned above. This example local.mk will create the debugging session when you type make debug . .PHONY : dbg - start dbg - attach debug build build : @ $( MAKE ) nvim dbg-start : build @tmux new-window -n 'dbg-neovim' 'gdbserver :6666 ./build/bin/nvim -D' dbg-attach : @tmux new-window -n 'dbg-cgdb' 'cgdb -x gdb_start.sh ./build/bin/nvim' debug : dbg - start dbg - attach Here gdb_start.sh includes gdb commands to be called when the debugger starts. It needs to attach to the server started by the dbg-start rule. For example: target remote localhost:6666 br main","title":"Using gdbserver in tmux"},{"location":"FAQ/#log-file-location","text":"Nvim's low-level logs are written to ~/.local/share/nvim/log (usually; see :help $NVIM_LOG_FILE ). Debug builds write INFO-level messages to this log file. You can specify the location with the $NVIM_LOG_FILE environment variable. Non-debug builds only log ERROR-level messages.","title":"Log file location"},{"location":"FAQ/#design","text":"","title":"Design"},{"location":"FAQ/#why-not-use-json-for-rpc","text":"JSON cannot easily/efficiently handle binary data JSON specification is ambiguous: http://seriot.ch/parsing_json.php","title":"Why not use JSON for RPC?"},{"location":"FAQ/#why-embed-lua-instead-of-x","text":"Lua is a very small language, ideal for embedding. The biggest advantage of Python/Ruby/etc is their huge collection of libraries, but that isn't relevant for Nvim, where Nvim is the \"batteries included\" library: introducing another stdlib would be redundant. Lua 5.1 is a complete language: the syntax is frozen. This is great for backwards compatibility. Nvim also uses Lua internally as an alternative to C. Extra performance is useful there, as opposed to a slow language like Python. LuaJIT is one of the fastest runtimes on the planet. It is at least 10x faster than Python. Python/JS cost more than Lua in terms of size and portability, and there are already numerous Python/JS-based editors. So Python/JS would make Nvim bigger and less portable, in exchange for a non-differentiating feature. See also: Why Lua Redis and scripting The Design of Lua Discussion of JavaScript vs Lua","title":"Why embed Lua instead of X?"},{"location":"FAQ/#why-lua-51-instead-of-lua-53","text":"Lua 5.1 is a different language than 5.3. The Lua org makes breaking changes with every new version, so even if we switched (not upgraded, but switched ) to 5.3 we gain nothing when they create the next new language in 5.4, 5.5, etc. And we would lose LuaJit, which is far more valuable than Lua 5.3+. Lua 5.1 is a complete language. To \"upgrade\" it, add libraries, not syntax. Nvim itself already is a pretty good \"stdlib\" for Lua, and we will continue to grow and enhance it. Changing the rules of Lua gains nothing in this context.","title":"Why Lua 5.1 instead of Lua 5.3+?"},{"location":"FAQ/#will-neovim-translate-viml-to-lua-instead-of-executing-viml-directly","text":"Update (2016): PR #243 implements the VimL-to-Lua translator. But it is blocked by technical concerns . Much of the work in that PR was re-used/re-purposed (viz. typval_T / vim_to_object refactor , eval.c refactor ).","title":"Will Neovim translate VimL to Lua, instead of executing VimL directly?"},{"location":"FAQ/#are-plugin-authors-encouraged-to-port-their-plugins-from-vimscript-to-lua-do-you-plan-on-supporting-vimscript-indefinitely-1152","text":"We don't anticipate any reason to deprecate Vimscript, which is a valuable DSL for text-editing tasks. Maintaining Vimscript compatibility is less costly than a mass migration of existing Vim plugins. Porting from Vimscript to Lua just for the heck of it gains nothing. Neovim is emphatically a fork of Vim in order to leverage the work already spent on thousands of Vim plugins, while enabling new types of plugins and integrations.","title":"Are plugin authors encouraged to port their plugins from Vimscript to Lua? Do you plan on supporting Vimscript indefinitely? (#1152)"},{"location":"Following-HEAD/","text":"The following changes may require users to update configuration, plugins, or expectations. Only breaking changes are mentioned here, this is not a reference for new features (see :help nvim instead). If you don't have Neovim, see Building Neovim or Installing Neovim . Use :checkhealth to detect and fix common problems. 2019/07/07 Floating windows no longer implicitly disables the number column. Instead use style='minimal' argument to nvim_open_win() to disable UI features like number column, End-of-buffer lines etc. 2019/06/10 #10123 Nvim core requires libluv . This may require building with -DUSE_BUNDLED_LUV=ON if you were previously using -DUSE_BUNDLED_LUV=OFF . Previously luv was only needed for running tests; now nvim statically links libluv in order to provide the vim.loop Lua interface. 2019/03/31 #9819 MenuPopupChanged renamed to CompleteChanged . 2019/01/20 #9526 : Neovim always uses the system allocator, instead of jemalloc. 2018/11/18 The Python package neovim was renamed to pynvim . \"Neovim\" can mean a lot of things. It can relate to the editor, or the project, or (prior to this change) the Python module, or the Ruby gem, etc. Especially confusing was the fact that the Python side would refer to it as neovim whereas the Neovim side referred to it as python-client . Now, both sides call it pynvim for the greater good. For the time being, neovim acts as a transitional package for the new pynvim . Unfortunately, due to limitations in pip, the neovim package cannot be safely upgraded with pip install --upgrade neovim on all systems. Steps to update \"pynvim\" (formerly \"neovim\") Python package: pip uninstall neovim pynvim pip install pynvim After those steps, it is safe to pip install neovim again, if any third-party package has it as a formal dependency. Otherwise it shouldn't be necessary. import neovim is still supported, both in plugins and third-party software using it as a library. If import neovim fails, then the upgrade wasn't successful. Follow the instructions above. 2018/09/22 #9024 : The meaning of the --embed and --headless flags changed to facilitate better startup behaviour with external UIs. UI embedders (any user of nvim_ui_attach ) must start Nvim without --headless : nvim --embed Embedders not using the UI protocol must use: nvim --embed --headless In the \" --embed only\" case Nvim waits for nvim_ui_attach before continuing startup (user config, reading buffers) so that UIs can deterministically handle (display) early messages, dialogs, etc. The client can do other requests before nvim_ui_attach (e.g. nvim_get_api_info for feature-detection). During this pre-startup phase the user config is of course not available (similar to --cmd ). For most UI embedders this improves startup behavior automatically, by supporting startup messages and swapfile dialogs. For others it is potentially a breaking change, which can be easily avoided by specifying --headless (which is backwards-compatible for that use-case). UIs that need additional initialization after init.vim can use this pattern: Before nvim_ui_attach send a single nvim_command request with the command \"autocmd VimEnter * call rpcrequest(1, 'vimenter')\" . In the vimenter method handler the UI can then safely execute any requests. Nvim will only enter normal mode when the handler returns (because rpcrequest() is a blocking call). 2018/06/10 Changes from #7679 : Nvim treats a stdin stream as text by default: echo foo | nvim To get the old behavior, pass stdin to -s : echo foo | nvim -s - Windows only: nvim *.txt (glob/wildcard expression) is treated literally . Use the :next ( :n ) command instead: nvim +\"n *.txt\" 2018/02/23 Default fillchars for 'vert' and 'sep' changed from respectively | and - to \u2502 and \u00b7 when the ambiwidth setting is different from double , else old defaults apply. #8035 2017/11/18 VimL (Vimscript) compatibility: count is no longer an alias to v:count . This helps avoid mistakes in scripts. #7407 2017/08/21 :terminal now starts in normal mode ( #6808 ), like any other buffer, instead of terminal mode. This avoids the cursor getting \"trapped\" when a terminal is started. 2017/05/15 The highlight option is now read-only ( #6737 ), so that the built-in highlight groups (and their behaviors) are predictable and can be used as keys for features like winhighlight . 2017/04/03 Default 'mouse' setting changed from mouse=a to mouse= (empty). This will change again in the future after mouse=a is improved. To continue using mouse, add this to your init.vim: set mouse=a 2017/04/02 Support for $NVIM_TUI_ENABLE_CURSOR_SHAPE was removed. Use the guicursor option to control cursor styling. See FAQ . To disable cursor style changes, set guicursor to empty: :set guicursor= Note: guicursor is enabled by default only if Nvim is certain it won't cause problems on your terminal. If you know that cursor shaping works on your terminal, set guicursor in your init.vim: :set guicursor=n-v-c:block-Cursor/lCursor-blinkon0,i-ci:ver25-Cursor/lCursor,r-cr:hor20-Cursor/lCursor 2016/12/12 #5529 merged Vim's support for \"partial functions\" which made Nvim more strict about when the implicit self variable is available. Functions that reference self (which is common with job callbacks) must either be declared as dict functions: function ! s:on_stdout ( id , data , event ) dict abort or as part of the job options dictionary: let s:opts = { ... } function ! s:opts.on_stdout ( id , data , event ) abort Job callbacks also must have at least 3 parameters now. See https://github.com/neovim/neovim/issues/5763#issuecomment-266722407 2016/11/05 [ 'encoding' ][encoding] cannot be changed to a value other than \"utf-8\", even during initialization. #2905 (Background: [#2929][2929] restricted 'encoding' to be modifiable only during initialization. One year later, we've found no problems with UTF-8 as the internal encoding, and are now making this mandatory. This only affects the internals of Nvim, it doesn't affect file encodings or plugins.) 2016/02/14 :filetype plugin indent on and :syntax on are now executed by default after your vimrc . If your vimrc calls :filetype , Neovim will not change your preference. If your vimrc calls :filetype off or :syntax off , that will be respected. If filetype plugin indent on and/or syntax on is in your vimrc, you can delete those lines. See :help startup for complete details. 2015/10/17 The 'viminfo' option is now an alias for 'shada' . 'viminfo' can no longer include n and it can no longer be shared with Vim. See #3469 for more information. 2015/07/26 The behavior of the mkdir() function has changed: Assuming /tmp/foo does not exist and /tmp can be written to, mkdir('/tmp/foo/bar', 'p', 0700) will create both /tmp/foo and /tmp/foo/bar with the octal permissions 0700. Vim's mkdir() will create /tmp/foo with 0755. If you try to create an existing directory with 'p' , such as with mkdir('/', 'p')) , mkdir() will silently fail. In Vim this was an error. Upon failure, mkdir() related error messages now include strerror() text. See #3041 for more information.","title":"Following-HEAD"},{"location":"Following-HEAD/#20190707","text":"Floating windows no longer implicitly disables the number column. Instead use style='minimal' argument to nvim_open_win() to disable UI features like number column, End-of-buffer lines etc.","title":"2019/07/07"},{"location":"Following-HEAD/#20190610","text":"#10123 Nvim core requires libluv . This may require building with -DUSE_BUNDLED_LUV=ON if you were previously using -DUSE_BUNDLED_LUV=OFF . Previously luv was only needed for running tests; now nvim statically links libluv in order to provide the vim.loop Lua interface.","title":"2019/06/10"},{"location":"Following-HEAD/#20190331","text":"#9819 MenuPopupChanged renamed to CompleteChanged .","title":"2019/03/31"},{"location":"Following-HEAD/#20190120","text":"#9526 : Neovim always uses the system allocator, instead of jemalloc.","title":"2019/01/20"},{"location":"Following-HEAD/#20181118","text":"The Python package neovim was renamed to pynvim . \"Neovim\" can mean a lot of things. It can relate to the editor, or the project, or (prior to this change) the Python module, or the Ruby gem, etc. Especially confusing was the fact that the Python side would refer to it as neovim whereas the Neovim side referred to it as python-client . Now, both sides call it pynvim for the greater good. For the time being, neovim acts as a transitional package for the new pynvim . Unfortunately, due to limitations in pip, the neovim package cannot be safely upgraded with pip install --upgrade neovim on all systems.","title":"2018/11/18"},{"location":"Following-HEAD/#steps-to-update-pynvim-formerly-neovim-python-package","text":"pip uninstall neovim pynvim pip install pynvim After those steps, it is safe to pip install neovim again, if any third-party package has it as a formal dependency. Otherwise it shouldn't be necessary. import neovim is still supported, both in plugins and third-party software using it as a library. If import neovim fails, then the upgrade wasn't successful. Follow the instructions above.","title":"Steps to update \"pynvim\" (formerly \"neovim\") Python package:"},{"location":"Following-HEAD/#20180922","text":"#9024 : The meaning of the --embed and --headless flags changed to facilitate better startup behaviour with external UIs. UI embedders (any user of nvim_ui_attach ) must start Nvim without --headless : nvim --embed Embedders not using the UI protocol must use: nvim --embed --headless In the \" --embed only\" case Nvim waits for nvim_ui_attach before continuing startup (user config, reading buffers) so that UIs can deterministically handle (display) early messages, dialogs, etc. The client can do other requests before nvim_ui_attach (e.g. nvim_get_api_info for feature-detection). During this pre-startup phase the user config is of course not available (similar to --cmd ). For most UI embedders this improves startup behavior automatically, by supporting startup messages and swapfile dialogs. For others it is potentially a breaking change, which can be easily avoided by specifying --headless (which is backwards-compatible for that use-case). UIs that need additional initialization after init.vim can use this pattern: Before nvim_ui_attach send a single nvim_command request with the command \"autocmd VimEnter * call rpcrequest(1, 'vimenter')\" . In the vimenter method handler the UI can then safely execute any requests. Nvim will only enter normal mode when the handler returns (because rpcrequest() is a blocking call).","title":"2018/09/22"},{"location":"Following-HEAD/#20180610","text":"Changes from #7679 : Nvim treats a stdin stream as text by default: echo foo | nvim To get the old behavior, pass stdin to -s : echo foo | nvim -s - Windows only: nvim *.txt (glob/wildcard expression) is treated literally . Use the :next ( :n ) command instead: nvim +\"n *.txt\"","title":"2018/06/10"},{"location":"Following-HEAD/#20180223","text":"Default fillchars for 'vert' and 'sep' changed from respectively | and - to \u2502 and \u00b7 when the ambiwidth setting is different from double , else old defaults apply. #8035","title":"2018/02/23"},{"location":"Following-HEAD/#20171118","text":"VimL (Vimscript) compatibility: count is no longer an alias to v:count . This helps avoid mistakes in scripts. #7407","title":"2017/11/18"},{"location":"Following-HEAD/#20170821","text":":terminal now starts in normal mode ( #6808 ), like any other buffer, instead of terminal mode. This avoids the cursor getting \"trapped\" when a terminal is started.","title":"2017/08/21"},{"location":"Following-HEAD/#20170515","text":"The highlight option is now read-only ( #6737 ), so that the built-in highlight groups (and their behaviors) are predictable and can be used as keys for features like winhighlight .","title":"2017/05/15"},{"location":"Following-HEAD/#20170403","text":"Default 'mouse' setting changed from mouse=a to mouse= (empty). This will change again in the future after mouse=a is improved. To continue using mouse, add this to your init.vim: set mouse=a","title":"2017/04/03"},{"location":"Following-HEAD/#20170402","text":"Support for $NVIM_TUI_ENABLE_CURSOR_SHAPE was removed. Use the guicursor option to control cursor styling. See FAQ . To disable cursor style changes, set guicursor to empty: :set guicursor= Note: guicursor is enabled by default only if Nvim is certain it won't cause problems on your terminal. If you know that cursor shaping works on your terminal, set guicursor in your init.vim: :set guicursor=n-v-c:block-Cursor/lCursor-blinkon0,i-ci:ver25-Cursor/lCursor,r-cr:hor20-Cursor/lCursor","title":"2017/04/02"},{"location":"Following-HEAD/#20161212","text":"#5529 merged Vim's support for \"partial functions\" which made Nvim more strict about when the implicit self variable is available. Functions that reference self (which is common with job callbacks) must either be declared as dict functions: function ! s:on_stdout ( id , data , event ) dict abort or as part of the job options dictionary: let s:opts = { ... } function ! s:opts.on_stdout ( id , data , event ) abort Job callbacks also must have at least 3 parameters now. See https://github.com/neovim/neovim/issues/5763#issuecomment-266722407","title":"2016/12/12"},{"location":"Following-HEAD/#20161105","text":"[ 'encoding' ][encoding] cannot be changed to a value other than \"utf-8\", even during initialization. #2905 (Background: [#2929][2929] restricted 'encoding' to be modifiable only during initialization. One year later, we've found no problems with UTF-8 as the internal encoding, and are now making this mandatory. This only affects the internals of Nvim, it doesn't affect file encodings or plugins.)","title":"2016/11/05"},{"location":"Following-HEAD/#20160214","text":":filetype plugin indent on and :syntax on are now executed by default after your vimrc . If your vimrc calls :filetype , Neovim will not change your preference. If your vimrc calls :filetype off or :syntax off , that will be respected. If filetype plugin indent on and/or syntax on is in your vimrc, you can delete those lines. See :help startup for complete details.","title":"2016/02/14"},{"location":"Following-HEAD/#20151017","text":"The 'viminfo' option is now an alias for 'shada' . 'viminfo' can no longer include n and it can no longer be shared with Vim. See #3469 for more information.","title":"2015/10/17"},{"location":"Following-HEAD/#20150726","text":"The behavior of the mkdir() function has changed: Assuming /tmp/foo does not exist and /tmp can be written to, mkdir('/tmp/foo/bar', 'p', 0700) will create both /tmp/foo and /tmp/foo/bar with the octal permissions 0700. Vim's mkdir() will create /tmp/foo with 0755. If you try to create an existing directory with 'p' , such as with mkdir('/', 'p')) , mkdir() will silently fail. In Vim this was an error. Upon failure, mkdir() related error messages now include strerror() text. See #3041 for more information.","title":"2015/07/26"},{"location":"GSoC-2018-Ideas/","text":"This page is for historical reference. UI protocol improvements ( DONE ) Desirable Skills: C and related tools Familiar with event-loop programming model Description: Nvim GUI:s are implemented as processes communicating with Nvim over a protocol. Currently this protocol exposes most functionality as a terminal-like screen grid. A long term goal is enabling richer UIs (including embeddings in GUI editors, like VSCode) by refactoring the protocol towards semantic updates and letting the GUI actually draw buffer contents and other screen elements. Currently this has been implemented for a few specific elements, like the completion popup menu and the command line. Expected Result: The UI protocol has gained new capabilities. This could involve substantial changes such as the GUI receiving redraw updates for each window separately, so that the GUI could be responsible for managing the overall layout of windows and statuslines. Alternatively, improvements could be done within the current global screen grid, such as the ability to display grid-aligned images in signs, buffers and statuslines. It could also involve adding semantic information to the grid, so that GUI:s can identify screen elements reliably rather than guessing it from highlights. Code license: Apache 2.0 Difficulty: Medium to Hard Student: ( @UtkarshMe ) Mentor: Bj\u00f6rn Linse ( @bfredl ) Java client Desirable Skills: Familiar with Vim/Nvim and Vim script (VimL) Moderate/High experience in Java Familiar with event-loop programming model Description: Implement a Nvim API client using Java. Implement a client, written in Java, which allows Java applications to control Nvim using the Nvim RPC API. If you are familiar with AWS or any other SaaS, note that a Nvim API client is just like a SDK for a REST web service, except that Nvim uses msgpack, not HTTP/JSON. The Nvmi RPC API is documented at :help api and :help rpc . To correctly implement the client one needs to understand the msgpack-rpc protocol. Some sort of event-loop mechanism will be needed to handle notifications. For reference, you can find clients in other languages at the related projects wiki page. The ultimate goal is to have a library that can be used to create plugins for IntelliJ and Eclipse . Minimizing third-party dependencies may help there. Expected Result: Java library that can be used to build Neovim extensions (UIs and other applications). Method signatures generated from nvim --api-info . Since nvim is already required (for --api-info ), the Java code-generation script could be written in Lua (which is built-in to nvim ). Passes the test suite used by the Nvim python-client . Using the python-client tests as a guide, create equivalent tests using a Java testing framework. Test suite should be runnable from the command-line (should not require an IDE) via maven/gradle (or some other industry-standard build-tool). Builds (and passes tests) on Linux (Travis CI) and Windows (AppVeyor) End-user deliverable should be compatible Java 6 (this is negotiable) Source-code can be latest version of Java (no backwards-compatibility requirement) Code license: Apache 2.0 Difficulty: Medium Mentor: Justin M Keyes ( @justinmk ) C# client ( DONE ) Desirable Skills: Familiar with Vim/Nvim and Vim script (VimL) Moderate/High experience in C# Familiar with event-loop programming model Description: Implement a Nvim API client using C#. Implement a client, written in C#, which allows C# applications to control Nvim using the Nvim RPC API. If you are familiar with AWS or any other SaaS, note that a Nvim API client is just like a SDK for a REST web service, except that Nvim uses msgpack, not HTTP/JSON. The Nvmi RPC API is documented at :help api and :help rpc . To correctly implement the client one needs to understand the msgpack-rpc protocol. Some sort of event-loop mechanism will be needed to handle notifications ( hint1 , hint2 ). For reference, you can find clients in other languages at the related projects wiki page. The ultimate goal is to have a library that can be used to create plugins for Visual Studio. Minimizing third-party dependencies may help there. Expected Result: C# library that can be used to create C#-based Neovim extensions (UIs and other applications). Method signatures generated from nvim --api-info . Since nvim is already required (for --api-info ), the C# code-generation build script could be written in Lua (which is built-in to nvim ). Passes the test suite used by the Nvim python-client . Using the python-client tests as a guide, create equivalent tests using a C# testing framework. Test suite should be runnable from the command-line (should not require an IDE) via MSBuild or some other industry-standard build-tool. Builds (and passes tests) on Linux (Travis CI) and Windows (AppVeyor) Builds against .NET Standard 2.0 Deliverable should be easy to install as a NuGet (or other) package. Source-code can be latest version of C# (no backwards-compatibility requirement) Code license: Apache 2.0 Difficulty: Medium Student: ( @b-r-o-c-k ) Mentor: Justin M Keyes ( @justinmk )","title":"GSoC-2018-Ideas"},{"location":"GSoC-2018-Ideas/#ui-protocol-improvements-done","text":"Desirable Skills: C and related tools Familiar with event-loop programming model Description: Nvim GUI:s are implemented as processes communicating with Nvim over a protocol. Currently this protocol exposes most functionality as a terminal-like screen grid. A long term goal is enabling richer UIs (including embeddings in GUI editors, like VSCode) by refactoring the protocol towards semantic updates and letting the GUI actually draw buffer contents and other screen elements. Currently this has been implemented for a few specific elements, like the completion popup menu and the command line. Expected Result: The UI protocol has gained new capabilities. This could involve substantial changes such as the GUI receiving redraw updates for each window separately, so that the GUI could be responsible for managing the overall layout of windows and statuslines. Alternatively, improvements could be done within the current global screen grid, such as the ability to display grid-aligned images in signs, buffers and statuslines. It could also involve adding semantic information to the grid, so that GUI:s can identify screen elements reliably rather than guessing it from highlights. Code license: Apache 2.0 Difficulty: Medium to Hard Student: ( @UtkarshMe ) Mentor: Bj\u00f6rn Linse ( @bfredl )","title":"UI protocol improvements (DONE)"},{"location":"GSoC-2018-Ideas/#java-client","text":"Desirable Skills: Familiar with Vim/Nvim and Vim script (VimL) Moderate/High experience in Java Familiar with event-loop programming model Description: Implement a Nvim API client using Java. Implement a client, written in Java, which allows Java applications to control Nvim using the Nvim RPC API. If you are familiar with AWS or any other SaaS, note that a Nvim API client is just like a SDK for a REST web service, except that Nvim uses msgpack, not HTTP/JSON. The Nvmi RPC API is documented at :help api and :help rpc . To correctly implement the client one needs to understand the msgpack-rpc protocol. Some sort of event-loop mechanism will be needed to handle notifications. For reference, you can find clients in other languages at the related projects wiki page. The ultimate goal is to have a library that can be used to create plugins for IntelliJ and Eclipse . Minimizing third-party dependencies may help there. Expected Result: Java library that can be used to build Neovim extensions (UIs and other applications). Method signatures generated from nvim --api-info . Since nvim is already required (for --api-info ), the Java code-generation script could be written in Lua (which is built-in to nvim ). Passes the test suite used by the Nvim python-client . Using the python-client tests as a guide, create equivalent tests using a Java testing framework. Test suite should be runnable from the command-line (should not require an IDE) via maven/gradle (or some other industry-standard build-tool). Builds (and passes tests) on Linux (Travis CI) and Windows (AppVeyor) End-user deliverable should be compatible Java 6 (this is negotiable) Source-code can be latest version of Java (no backwards-compatibility requirement) Code license: Apache 2.0 Difficulty: Medium Mentor: Justin M Keyes ( @justinmk )","title":"Java client"},{"location":"GSoC-2018-Ideas/#c-client-done","text":"Desirable Skills: Familiar with Vim/Nvim and Vim script (VimL) Moderate/High experience in C# Familiar with event-loop programming model Description: Implement a Nvim API client using C#. Implement a client, written in C#, which allows C# applications to control Nvim using the Nvim RPC API. If you are familiar with AWS or any other SaaS, note that a Nvim API client is just like a SDK for a REST web service, except that Nvim uses msgpack, not HTTP/JSON. The Nvmi RPC API is documented at :help api and :help rpc . To correctly implement the client one needs to understand the msgpack-rpc protocol. Some sort of event-loop mechanism will be needed to handle notifications ( hint1 , hint2 ). For reference, you can find clients in other languages at the related projects wiki page. The ultimate goal is to have a library that can be used to create plugins for Visual Studio. Minimizing third-party dependencies may help there. Expected Result: C# library that can be used to create C#-based Neovim extensions (UIs and other applications). Method signatures generated from nvim --api-info . Since nvim is already required (for --api-info ), the C# code-generation build script could be written in Lua (which is built-in to nvim ). Passes the test suite used by the Nvim python-client . Using the python-client tests as a guide, create equivalent tests using a C# testing framework. Test suite should be runnable from the command-line (should not require an IDE) via MSBuild or some other industry-standard build-tool. Builds (and passes tests) on Linux (Travis CI) and Windows (AppVeyor) Builds against .NET Standard 2.0 Deliverable should be easy to install as a NuGet (or other) package. Source-code can be latest version of C# (no backwards-compatibility requirement) Code license: Apache 2.0 Difficulty: Medium Student: ( @b-r-o-c-k ) Mentor: Justin M Keyes ( @justinmk )","title":"C# client (DONE)"},{"location":"GSoC-2019-Ideas/","text":"Contributing to this list: Ideas page Manual Example Introduction Below is a list of project ideas for Google Summer of Code . These projects may require familiarity with C, Makefiles, Lua or VimL (\"Vim script\"). Neovim is a text editor based on Vim. One of the project goals is to encourage hacking and collaboration. Effort is put into removing barriers for contributors and improving documentation. The wiki has sections on developing and contributing to help you get started. The Neovim source has roots going back to 1987 which means libraries such as libuv were not around at that time. The codebase can be made easier to maintain and understand by using these libraries. Project ideas that involve working heavily with internals will in general be more difficult than project ideas that \"simply\" add new features. However working with older/complex parts of the code base can also provide valuable learning feedback for writing simpler and more maintainable code. There is a large range of skills that can be learned and working with the team to find a project that will help you the most is in your benefit. Visit gitter.im/neovim or #neovim on IRC to discuss these projects with the community and our mentors. Because communication is a big part of open source development you are expected to get in touch with us before making your application. It's also recommended to start with a smaller coding task, to get introduced to the Neovim project. Look on the issue tracker for simpler issues and submit a small PR attempting to solve the issue. See for instance the good first issue and complexity:low tags. The goal here is to get accustomed with the codebase and to our workflow for reviewing and testing PRs, rather than directly making a large code contribution. The following list of projects are just some ideas. We are happy to hear any suggestions that you may have. Making a proposal The application period for GSOC is March 25-April 9. Send your proposal through the official GSOC page . We encourage students to send a first draft early in this period, this allows us to give feedback and and ask for more information if need. See https://google.github.io/gsocguides/student/writing-a-proposal for some guidelines for writing a good proposal. Note: this year we will likely be able to accept 2-3 students. We expect to get more strong proposals than available slots, so we will need to turn some good proposals down. Proposal evaluation Proposal evaluation criteria: http://intermine.org/gsoc/guidance/grading-criteria-2019/ Tips Anywhere a Vim concept (such as \"textlock\") is mentioned, you can find what it means by using the \":help\" command from within neovim ( :help textlock ). Ask questions and post your partial work frequently (say, once every day or 2, if possible). It's OK if work is messy; just put \"[WIP]\" in the pull request (PR) title. Take advantage of the continuous integration (CI) systems which automatically run against your pull requests. When you send work to a PR, the full test-suite runs on the PR while you continue to work locally. The wiki contains up-to-date documentation on building, debugging, and development tips. Only a text editor, CMake, and a compiler are needed to develop Neovim. Ctags is very helpful also. The contributing guidelines are intended to be helpful, not rigid. Projects New Features \"Multiprocessing\" feature TUI client Improve Lua configurability GUI Features Live preview of commands Improve autoread \"Multiprocessing\" feature Desirable Skills: Experience with concurrency and interprocess communication Strong experience with C Familiar with VimL (Vim script) and Vim concepts (quickfix list, buffers, etc.) Description: p2p architecture for data sharing between multiple Nvim instances. Similar to Python's multiprocessing module, the idea is to to offload Nvim tasks (VimL and/or Lua) to child Nvim processes. Here's a picture of the potential workflow: parent calls invoke_async(Foo) parent spawns new child nvim process parent sends command name Foo + state to child parent does other, unrelated work child completes its Foo work child sends notification (method name + state) to parent Difficulty: Hard Code license: Apache 2.0 Mentor: Justin M Keyes ( @justinmk ) TUI (Terminal UI) remote attachment Desirable Skills: C Description: The built-in UI is called the TUI. It looks like Vim, but internally it is decoupled from the UI and \"screen\" layout subsystem. It was designed to be able to connect to other (remote) instances of Nvim, but this hasn't been implemented yet. #7438 Nvim is both a server and a client. Nvim (client) can connect to any other Nvim (server). And Nvim GUIs can show the screen of a remote Nvim server. But the built-in Nvim TUI cannot show the screen of a remote Nvim server. That's the goal of this project. It is not \"live share\". It's just showing the remote UI in a client TUI. Networking question are out of scope. It is assumed the client has an SSH tunnel or named pipe to connect to. The Nvim API model is: :help api : general API functions :help ui : UI events Any client can call any API function. If a client calls nvim_ui_attach , then it is a \"UI client\". This simply means that Nvim will send UI events as msgpack-rpc notifications on the channel. That's how every Nvim UI works. And that's how the TUI client (this project proposal) will work. Python \"demo UI\" may be helpful: https://github.com/neovim/python-gui The simplest UI is the \"fake UI\" implemented in test/functional/ui/screen.lua from the Nvim test suite. It creates a text UI from real Nvim UI events. This allows us to write Lua tests that check the state of the UI, by simply writing the text UI in the test. In the Neoivm repo, \"git grep 'screen:expect'\" shows all of the places where this is used. The example_spec.lua test shows a simple example. You can try it by running this shell command: TEST_FILE=test/functional/example_spec.lua make functionaltest Overview of the screen.lua \"fake UI\" implementation: Screen._wait() / Screen:sleep() runs the event loop to consume UI events Screen:_redraw() dispatches UI events to the appropriate handlers For example Screen:_handle_grid_line() consumes a line event, and updates some tables (self._grids and self._attr_table). And those tables are literally the contents of the fake UI that Screen:expect() tests against. Use cases: Connect to any Nvim. Unlike tmux, Nvim UI client can connect to any other running Nvim, including GUIs. Potential for using libnvim as the RPC core of any Nvim API client, to eliminate the need for clients to implement their own msgpack-RPC handling. Expected Result: Implement a TUI \"remote UI\" client. Modify the TUI subsystem so that it can display a remote Nvim instance. The C codebase already has msgpack support, an event-loop, and the ability to connect to sockets/named pipes/etc. Extend tui/tui.c to: connect to a channel get UI events from the channel unpack the events and call the appropriate handlers Extend tui/input.c to: send user input to the channel (i.e. call the nvim_input() API function) Example: nvim --servername foo will connect to the Nvim server at address foo . The nvim client instance sends input to the remote Nvim server, and reflects the UI of the remote Nvim server. So the nvim client acts like any other external (G)UI. Difficulty: Medium Code license: Apache 2.0 Mentor: Justin M Keyes ( @justinmk ), Bj\u00f6rn Linse ( @bfredl ) Support for Lua plugins and configuration Desirable Skills: C and related tools Familiarity with Lua C API is a plus. Description: Nvim is always built with a builtin Lua interpreter. A goal is to make Lua a first class language for plugins and user config, which can access editor functionality directly, without \"shelling out\" to VimL commands and functions. Expected Result: More functionality is directly exposed to Lua. This project idea is a bit open ended, and improvements can be made in different directions. Regardless what priorities are decided, it is expected that the project will take form as multiple smaller deliverables that will be merged separately during the duration of the project. The project can involve calls the core editor makes to VimL, such as autocommands, mappings and function-based options like 'omnifunc' , where native Lua support could be added. Lua access to jobs and channels would also be worthwhile. Nvim is working on building a Lua standard library to make it convenient to write plugins and user config in Lua. This goal is broad, and discussion with the plugin developing community is encouraged, about what functionality would be most useful for the standard library. Another direction is to add new extension points, such as letting Lua code control aspects of screen drawing. A starting point could be to let Lua code draw a richer completion popup menu for the TUI, by processing popup menu UI events internally. Difficulty: Medium Code license: Apache 2.0 Mentor: Bj\u00f6rn Linse ( @bfredl ) GUI Features Desirable Skills: C and related tools Familiar with event-loop programming model Description: Nvim GUIs are implemented as processes communicating with Nvim. Originally the UI protocol exposed most functionality as a single, terminal-like screen grid. Work has been done to allow UIs (including embeddings in GUI editors, like VSCode) to render the screen layout themselves, based on semantic updates from Nvim. Some screen elements like the cmdline, popupmenu and message area has been externalized. As a result of a 2018 GSOC project , windows can be drawn on separate grids. Expected Result: Further improvements to the GUI protocol. Some UIs want to render the buffer contents themselves. A solution would be a UI protocol mode, where the rendered grid is not used, rather all decorations, such as syntax highlighting, conceals, virtual text are transmitted for the current viewport. Such an UI would be able to render text without the restrictions of the builtin monospace grid. Then the UI should be able to inform nvim about usage of virtual columns and wrapping, so that vim commands such as gj are consistent with how text is presented to the user. Another path is to improve the core Nvim grid model. We could allow the width and height of cells be different for each row. This would allow for heading text with different font size, and pictures rendered inside windows. Putting forward your own ideas of UI improvements is encouraged. Read the docs for the implemented extensions as well as the tracking issue for ongoing/planned work, as a starting point. Difficulty: Medium-Hard Code license: Apache 2.0 Mentor: Bj\u00f6rn Linse ( @bfredl ) Live preview of commands Desirable Skills: C and related tools Familiar with event-loop programming model Description: Nvim has builtin live preview of :%s substitution, as a result of a [[successful collaboration with students| https://medium.com/@eric.burel/stop-using-open-source-5cb19baca44d ]]. This support could be extended to more commands, such as :global and :normal . Expected Result: More commands support interactive preview. This could be done by extending the hard-coded support for substitution preview to more commands. Alternatively, a more scalable approach could be to add core functionality that makes it easier to implement live preview as plugins in VimL and/or Lua. See [[#7370| https://github.com/neovim/neovim/issues/7370 ]] for some ideas. Difficulty: Medium-Hard. Code license: Apache 2.0 Mentor: Bj\u00f6rn Linse ( @bfredl ) Improve autoread Desirable Skills: Any Description: Reload file/notify user when a file being edited changes outside of nvim . Expected Result: Neovim has the 'autoread' setting that regularly checks if a file edited in neovim has been externally modified. It thus notifies the user to prevent overwriting the changes. Sadly the current mechanism isn't foolproof. This project intends to make this feature work as well as in other editors like Sublime text and across the Neovim-supported platforms. The interface should also be improved so that notifications show how different the edited and modified files are. The candidate can realize some of the difficulties involved with this proposition for linux Difficulty: Medium Code license: Apache 2.0 Mentor: Matthieu Coudron ( @teto ) Neovim-based \"Vim mode\" Desirable Skills: Any Description: Implement \"Vim mode\" in an editor/IDE (such as IntelliJ) by embedding a nvim instance. Expected Result: Full Nvim editing should be available in the editor/IDE, while also allowing the user to use the native editor/IDE features. Examples: VSCode integration Sublime Text integration Difficulty: Medium Code license: Apache 2.0 Mentor: Horace He ( @chillee ) Please add your project ideas in the following format. Title Desirable Skills: Description: Expected Result: Item1 Item2 Difficulty: Easy/Medium/Hard Code license: Apache 2.0 Mentor: Mentor name ( @MentorName )","title":"GSoC-2019-Ideas"},{"location":"GSoC-2019-Ideas/#contributing-to-this-list","text":"Ideas page Manual Example","title":"Contributing to this list:"},{"location":"GSoC-2019-Ideas/#introduction","text":"Below is a list of project ideas for Google Summer of Code . These projects may require familiarity with C, Makefiles, Lua or VimL (\"Vim script\"). Neovim is a text editor based on Vim. One of the project goals is to encourage hacking and collaboration. Effort is put into removing barriers for contributors and improving documentation. The wiki has sections on developing and contributing to help you get started. The Neovim source has roots going back to 1987 which means libraries such as libuv were not around at that time. The codebase can be made easier to maintain and understand by using these libraries. Project ideas that involve working heavily with internals will in general be more difficult than project ideas that \"simply\" add new features. However working with older/complex parts of the code base can also provide valuable learning feedback for writing simpler and more maintainable code. There is a large range of skills that can be learned and working with the team to find a project that will help you the most is in your benefit. Visit gitter.im/neovim or #neovim on IRC to discuss these projects with the community and our mentors. Because communication is a big part of open source development you are expected to get in touch with us before making your application. It's also recommended to start with a smaller coding task, to get introduced to the Neovim project. Look on the issue tracker for simpler issues and submit a small PR attempting to solve the issue. See for instance the good first issue and complexity:low tags. The goal here is to get accustomed with the codebase and to our workflow for reviewing and testing PRs, rather than directly making a large code contribution. The following list of projects are just some ideas. We are happy to hear any suggestions that you may have.","title":"Introduction"},{"location":"GSoC-2019-Ideas/#making-a-proposal","text":"The application period for GSOC is March 25-April 9. Send your proposal through the official GSOC page . We encourage students to send a first draft early in this period, this allows us to give feedback and and ask for more information if need. See https://google.github.io/gsocguides/student/writing-a-proposal for some guidelines for writing a good proposal. Note: this year we will likely be able to accept 2-3 students. We expect to get more strong proposals than available slots, so we will need to turn some good proposals down.","title":"Making a proposal"},{"location":"GSoC-2019-Ideas/#proposal-evaluation","text":"Proposal evaluation criteria: http://intermine.org/gsoc/guidance/grading-criteria-2019/","title":"Proposal evaluation"},{"location":"GSoC-2019-Ideas/#tips","text":"Anywhere a Vim concept (such as \"textlock\") is mentioned, you can find what it means by using the \":help\" command from within neovim ( :help textlock ). Ask questions and post your partial work frequently (say, once every day or 2, if possible). It's OK if work is messy; just put \"[WIP]\" in the pull request (PR) title. Take advantage of the continuous integration (CI) systems which automatically run against your pull requests. When you send work to a PR, the full test-suite runs on the PR while you continue to work locally. The wiki contains up-to-date documentation on building, debugging, and development tips. Only a text editor, CMake, and a compiler are needed to develop Neovim. Ctags is very helpful also. The contributing guidelines are intended to be helpful, not rigid.","title":"Tips"},{"location":"GSoC-2019-Ideas/#projects","text":"New Features \"Multiprocessing\" feature TUI client Improve Lua configurability GUI Features Live preview of commands Improve autoread","title":"Projects"},{"location":"GSoC-2019-Ideas/#multiprocessing-feature","text":"Desirable Skills: Experience with concurrency and interprocess communication Strong experience with C Familiar with VimL (Vim script) and Vim concepts (quickfix list, buffers, etc.) Description: p2p architecture for data sharing between multiple Nvim instances. Similar to Python's multiprocessing module, the idea is to to offload Nvim tasks (VimL and/or Lua) to child Nvim processes. Here's a picture of the potential workflow: parent calls invoke_async(Foo) parent spawns new child nvim process parent sends command name Foo + state to child parent does other, unrelated work child completes its Foo work child sends notification (method name + state) to parent Difficulty: Hard Code license: Apache 2.0 Mentor: Justin M Keyes ( @justinmk )","title":"\"Multiprocessing\" feature"},{"location":"GSoC-2019-Ideas/#tui-terminal-ui-remote-attachment","text":"Desirable Skills: C Description: The built-in UI is called the TUI. It looks like Vim, but internally it is decoupled from the UI and \"screen\" layout subsystem. It was designed to be able to connect to other (remote) instances of Nvim, but this hasn't been implemented yet. #7438 Nvim is both a server and a client. Nvim (client) can connect to any other Nvim (server). And Nvim GUIs can show the screen of a remote Nvim server. But the built-in Nvim TUI cannot show the screen of a remote Nvim server. That's the goal of this project. It is not \"live share\". It's just showing the remote UI in a client TUI. Networking question are out of scope. It is assumed the client has an SSH tunnel or named pipe to connect to. The Nvim API model is: :help api : general API functions :help ui : UI events Any client can call any API function. If a client calls nvim_ui_attach , then it is a \"UI client\". This simply means that Nvim will send UI events as msgpack-rpc notifications on the channel. That's how every Nvim UI works. And that's how the TUI client (this project proposal) will work. Python \"demo UI\" may be helpful: https://github.com/neovim/python-gui The simplest UI is the \"fake UI\" implemented in test/functional/ui/screen.lua from the Nvim test suite. It creates a text UI from real Nvim UI events. This allows us to write Lua tests that check the state of the UI, by simply writing the text UI in the test. In the Neoivm repo, \"git grep 'screen:expect'\" shows all of the places where this is used. The example_spec.lua test shows a simple example. You can try it by running this shell command: TEST_FILE=test/functional/example_spec.lua make functionaltest Overview of the screen.lua \"fake UI\" implementation: Screen._wait() / Screen:sleep() runs the event loop to consume UI events Screen:_redraw() dispatches UI events to the appropriate handlers For example Screen:_handle_grid_line() consumes a line event, and updates some tables (self._grids and self._attr_table). And those tables are literally the contents of the fake UI that Screen:expect() tests against. Use cases: Connect to any Nvim. Unlike tmux, Nvim UI client can connect to any other running Nvim, including GUIs. Potential for using libnvim as the RPC core of any Nvim API client, to eliminate the need for clients to implement their own msgpack-RPC handling. Expected Result: Implement a TUI \"remote UI\" client. Modify the TUI subsystem so that it can display a remote Nvim instance. The C codebase already has msgpack support, an event-loop, and the ability to connect to sockets/named pipes/etc. Extend tui/tui.c to: connect to a channel get UI events from the channel unpack the events and call the appropriate handlers Extend tui/input.c to: send user input to the channel (i.e. call the nvim_input() API function) Example: nvim --servername foo will connect to the Nvim server at address foo . The nvim client instance sends input to the remote Nvim server, and reflects the UI of the remote Nvim server. So the nvim client acts like any other external (G)UI. Difficulty: Medium Code license: Apache 2.0 Mentor: Justin M Keyes ( @justinmk ), Bj\u00f6rn Linse ( @bfredl )","title":"TUI (Terminal UI) remote attachment"},{"location":"GSoC-2019-Ideas/#support-for-lua-plugins-and-configuration","text":"Desirable Skills: C and related tools Familiarity with Lua C API is a plus. Description: Nvim is always built with a builtin Lua interpreter. A goal is to make Lua a first class language for plugins and user config, which can access editor functionality directly, without \"shelling out\" to VimL commands and functions. Expected Result: More functionality is directly exposed to Lua. This project idea is a bit open ended, and improvements can be made in different directions. Regardless what priorities are decided, it is expected that the project will take form as multiple smaller deliverables that will be merged separately during the duration of the project. The project can involve calls the core editor makes to VimL, such as autocommands, mappings and function-based options like 'omnifunc' , where native Lua support could be added. Lua access to jobs and channels would also be worthwhile. Nvim is working on building a Lua standard library to make it convenient to write plugins and user config in Lua. This goal is broad, and discussion with the plugin developing community is encouraged, about what functionality would be most useful for the standard library. Another direction is to add new extension points, such as letting Lua code control aspects of screen drawing. A starting point could be to let Lua code draw a richer completion popup menu for the TUI, by processing popup menu UI events internally. Difficulty: Medium Code license: Apache 2.0 Mentor: Bj\u00f6rn Linse ( @bfredl )","title":"Support for Lua plugins and configuration"},{"location":"GSoC-2019-Ideas/#gui-features","text":"Desirable Skills: C and related tools Familiar with event-loop programming model Description: Nvim GUIs are implemented as processes communicating with Nvim. Originally the UI protocol exposed most functionality as a single, terminal-like screen grid. Work has been done to allow UIs (including embeddings in GUI editors, like VSCode) to render the screen layout themselves, based on semantic updates from Nvim. Some screen elements like the cmdline, popupmenu and message area has been externalized. As a result of a 2018 GSOC project , windows can be drawn on separate grids. Expected Result: Further improvements to the GUI protocol. Some UIs want to render the buffer contents themselves. A solution would be a UI protocol mode, where the rendered grid is not used, rather all decorations, such as syntax highlighting, conceals, virtual text are transmitted for the current viewport. Such an UI would be able to render text without the restrictions of the builtin monospace grid. Then the UI should be able to inform nvim about usage of virtual columns and wrapping, so that vim commands such as gj are consistent with how text is presented to the user. Another path is to improve the core Nvim grid model. We could allow the width and height of cells be different for each row. This would allow for heading text with different font size, and pictures rendered inside windows. Putting forward your own ideas of UI improvements is encouraged. Read the docs for the implemented extensions as well as the tracking issue for ongoing/planned work, as a starting point. Difficulty: Medium-Hard Code license: Apache 2.0 Mentor: Bj\u00f6rn Linse ( @bfredl )","title":"GUI Features"},{"location":"GSoC-2019-Ideas/#live-preview-of-commands","text":"Desirable Skills: C and related tools Familiar with event-loop programming model Description: Nvim has builtin live preview of :%s substitution, as a result of a [[successful collaboration with students| https://medium.com/@eric.burel/stop-using-open-source-5cb19baca44d ]]. This support could be extended to more commands, such as :global and :normal . Expected Result: More commands support interactive preview. This could be done by extending the hard-coded support for substitution preview to more commands. Alternatively, a more scalable approach could be to add core functionality that makes it easier to implement live preview as plugins in VimL and/or Lua. See [[#7370| https://github.com/neovim/neovim/issues/7370 ]] for some ideas. Difficulty: Medium-Hard. Code license: Apache 2.0 Mentor: Bj\u00f6rn Linse ( @bfredl )","title":"Live preview of commands"},{"location":"GSoC-2019-Ideas/#improve-autoread","text":"Desirable Skills: Any Description: Reload file/notify user when a file being edited changes outside of nvim . Expected Result: Neovim has the 'autoread' setting that regularly checks if a file edited in neovim has been externally modified. It thus notifies the user to prevent overwriting the changes. Sadly the current mechanism isn't foolproof. This project intends to make this feature work as well as in other editors like Sublime text and across the Neovim-supported platforms. The interface should also be improved so that notifications show how different the edited and modified files are. The candidate can realize some of the difficulties involved with this proposition for linux Difficulty: Medium Code license: Apache 2.0 Mentor: Matthieu Coudron ( @teto )","title":"Improve autoread"},{"location":"GSoC-2019-Ideas/#neovim-based-vim-mode","text":"Desirable Skills: Any Description: Implement \"Vim mode\" in an editor/IDE (such as IntelliJ) by embedding a nvim instance. Expected Result: Full Nvim editing should be available in the editor/IDE, while also allowing the user to use the native editor/IDE features. Examples: VSCode integration Sublime Text integration Difficulty: Medium Code license: Apache 2.0 Mentor: Horace He ( @chillee ) Please add your project ideas in the following format.","title":"Neovim-based \"Vim mode\""},{"location":"GSoC-2019-Ideas/#title","text":"Desirable Skills: Description: Expected Result: Item1 Item2 Difficulty: Easy/Medium/Hard Code license: Apache 2.0 Mentor: Mentor name ( @MentorName )","title":"Title"},{"location":"GSoC/","text":"GSoC 2019 GSoC 2018","title":"GSoC"},{"location":"Generate-callgraphs-with-Doxygen/","text":"You can use doxygen to create callgraphs of all the functions in neovim as well as annotated source code with cross references (currently neovim does not use any doxygen comments so that is all you can get out of it for now). In order to do that you will have to run the doxygen command with a an appropriate configuration file in the neovim root directory like so doxygen configfile You can create a default configuration file with doxygen using the -g flag doxygen -g configfilename In order to create the callgraphs you will need to set the following options in your doxygen config file # This first one is optional PROJECT_NAME = \"Neovim\" OPTIMIZE_OUTPUT_FOR_C = YES EXTRACT_ALL = YES EXTRACT_STATIC = YES # Set only the dirs you want INPUT = src/ test/ RECURSIVE = YES SOURCE_BROWSER = YES HAVE_DOT = YES # Set according to your system DOT_NUM_THREADS = 3 CALL_GRAPH = YES CALLER_GRAPH = YES (The default config file with the above changes applied can be found here ) Note that you will need the dot program (from the graphviz tool collection) to be installed when starting doxygen. Doxygen will call it to generate the graphs. Attention: The above configuration will result in doxygen running for about 30 minutes and generating around 2.1GB worth of documentation. A reasonably recent version of the callgraphs should be accessible here if you do not want to generate them yourself.","title":"Generate-callgraphs-with-Doxygen"},{"location":"Home/","text":"Introduction FAQ Transitioning from Vim :help nvim-from-vim Related projects Google Summer of Code (GSoC) 2019 Users Install Following HEAD Documentation Developers Build Contribute Tests Refactoring guidelines Merging patches from upstream Vim Style guide Source Documentation Plugin Architecture Code overview C programming techniques and Neovim-specific guidance C refactorings and code-smells Integer type semantics Ideas Refactor Vim into a library Architectural musing and ideas (text buffer data structure, ...)","title":"Home"},{"location":"Home/#users","text":"Install Following HEAD Documentation","title":"Users"},{"location":"Home/#developers","text":"Build Contribute Tests Refactoring guidelines Merging patches from upstream Vim Style guide Source Documentation Plugin Architecture Code overview C programming techniques and Neovim-specific guidance C refactorings and code-smells Integer type semantics","title":"Developers"},{"location":"Home/#ideas","text":"Refactor Vim into a library Architectural musing and ideas (text buffer data structure, ...)","title":"Ideas"},{"location":"Installing-Neovim/","text":"You can install Neovim from download , package , or source in just a few seconds. To start Neovim, run nvim (not neovim ). Before upgrading to a new version, check Following HEAD . For config (vimrc) see the FAQ . Install from download Downloads are available on the Releases page. Latest stable release Latest development prerelease Install from package Packages are listed below. (You can also build Neovim from source .) Windows Chocolatey Release (v0.3): choco install neovim (use -y for automatically skipping confirmation messages) Development (pre-release): choco install neovim --pre Scoop Release: scoop install neovim Development (pre-release): scoop bucket add versions scoop install neovim-nightly Pre-built archives If you are missing VCRUNTIME140.dll , install the Visual Studio 2015 C++ redistributable (choose x86_64 or x86 depending on your system). Choose a package ( nvim-winXX.zip ) from the releases page . Unzip the package. Any location is fine, administrator privileges are not required. $VIMRUNTIME will be set to that location automatically. Double-click nvim-qt.exe . Optional steps: Add the bin folder (e.g. C:\\Program Files\\nvim\\bin ) to your PATH. This makes it easy to run nvim and nvim-qt from anywhere. If :set spell does not work, create the C:/Users/foo/AppData/Local/nvim/site/spell folder. You can then copy your spell files over (for English, located here and here ); For Python plugins you need the pynvim module. \"Virtual envs\" are recommended. After activating the virtual env do pip install pynvim (in both ). Edit your init.vim so that it contains the path to the env's Python executable: let g :python3_host_prog = 'C:/Users/foo/Envs/neovim3/Scripts/python.exe' let g :python_host_prog = 'C:/Users/foo/Envs/neovim/Scripts/python.exe' Run :checkhealth and read :help provider-python . init.vim (\"vimrc\"): If you already have Vim installed you can copy %userprofile%\\_vimrc to %userprofile%\\AppData\\Local\\nvim\\init.vim to use your Vim config with Neovim. macOS / OS X Pre-built archives The Releases page provides pre-built binaries for macOS 10.11+. curl -LO https://github.com/neovim/neovim/releases/download/nightly/nvim-macos.tar.gz tar xzf nvim-macos.tar.gz ./nvim-osx64/bin/nvim Homebrew (macOS) / Linuxbrew (Linux) brew install neovim Or install the development version of Nvim: brew install --HEAD neovim Macports sudo port selfupdate sudo port install neovim Linux AppImage (\"universal\" Linux package) The Releases page provides an AppImage that runs on most Linux systems. No installation is needed, just download nvim.appimage and run it. (It might not work if your Linux distribution is more than 4 years old.) curl -LO https://github.com/neovim/neovim/releases/download/stable/nvim.appimage chmod u+x nvim.appimage ./nvim.appimage Arch Linux Neovim can be installed from the community repository: sudo pacman -S neovim Alternatively, Neovim can be also installed using the PKGBUILD neovim-git , available on the AUR . Alternatively, Neovim Nightly builds can be also installed using the PKGBUILD neovim-nightly , available on the AUR . The Python module is available from the community repository: sudo pacman -S python-pynvim Python 2 and Ruby modules (currently only supported in neovim-git ) are available from the AUR as python2-neovim and ruby-neovim respectively. CentOS 7 / RHEL 7 Neovim is available through EPEL (Extra Packages for Enterprise Linux) yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm yum install -y neovim python3-neovim # you might need python2-neovim as well on older Fedora releases Clear Linux OS NeoVim is available through the neovim bundle sudo swupd bundle-add neovim Python ( :python ) support is available if the python-basic bundle is installed. sudo swupd bundle-add python-basic CRUX A CRUX port is available under 6c37/neovim , along with ports for other dependencies of Neovim. For instructions on how to install the Python modules, see [ :help provider-python ]. Debian Neovim is in Debian . sudo apt-get install neovim Python ( :python ) support is installable via the package manager on Debian unstable. sudo apt-get install python-neovim sudo apt-get install python3-neovim Exherbo Linux Exhereses for scm and released versions are currently available in repository ::medvid . Python client (with GTK+ GUI included) and Qt5 GUI are also available as suggestions: cave resolve app-editors/neovim --take dev-python/neovim-python --take app-editors/neovim-qt Fedora Neovim is in Fedora starting with Fedora 25: dnf install -y neovim python{2,3}-neovim You can also get nightly builds of git master from the Copr automated build system : dnf copr enable agriffis/neovim-nightly dnf install -y neovim python{2,3}-neovim See the blog post for information on how these are built. Flatpak You can find Neovim on Flathub . Providing you have Flatpak set up : flatpak install flathub io.neovim.nvim flatpak run io.neovim.nvim You can add /var/lib/flatpak/exports/bin (or ~/.local/share/flatpak/exports/bin if you used --user ) to the $PATH and run it with io.neovim.nvim . Note that Flatpak'ed Neovim will look for init.vim in ~/.var/app/io.neovim.nvim/config/nvim instead of ~/.config/nvim . Gentoo Linux An ebuild is available in Gentoo's official portage repository: emerge -a app-editors/neovim GNU Guix Neovim can be installed with: guix install neovim Nix / NixOS Neovim can be installed with: nix-env -iA nixpkgs.neovim To install the Python modules: nix-env -iA nixpkgs.python3Packages.pynvim Replace python3 with python2 for the python 2 packages. Mageia 7 urpmi neovim To install the Python modules: urpmi python2-pynvim python3-pynvim OpenSUSE Neovim can be installed with: sudo zypper in neovim To install the Python modules: sudo zypper in python-neovim python3-neovim PLD Linux Neovim is in PLD Linux : poldek -u neovim poldek -u python-neovim python3-neovim poldek -u python-neovim-gui python3-neovim-gui Slackware See neovim on SlackBuilds . For instructions on how to install the Python modules, see [ :help provider-python ]. Source Mage Neovim can be installed using the Sorcery package manager: cast neovim Solus Neovim can be installed using the default package manager in Solus (eopkg): sudo eopkg install neovim Snap Neovim nightly and stable are available on the snap store . Stable Builds sudo snap install --candidate nvim --classic Nightly Builds sudo snap install --edge nvim --classic Ubuntu Since 18.04 As in Debian, Neovim is in Ubuntu . sudo apt install neovim Python ( :python ) support seems to be automatically installed sudo apt install python-neovim sudo apt install python3-neovim Before 18.04 Neovim has been added to a \"Personal Package Archive\" (PPA). This allows you to install it with apt-get . Follow the links to the PPAs to see which versions of Ubuntu are currently available via the PPA. Choose stable or unstable : https://launchpad.net/~neovim-ppa/+archive/ubuntu/ stable (Xenial 16.04 or newer only). https://launchpad.net/~neovim-ppa/+archive/ubuntu/ unstable To be able to use add-apt-repository you may need to install software-properties-common: sudo apt-get install software-properties-common If you're using an older version Ubuntu you must use: sudo apt-get install python-software-properties Run the following commands: sudo add-apt-repository ppa:neovim-ppa/stable sudo apt-get update sudo apt-get install neovim Prerequisites for the Python modules: sudo apt-get install python-dev python-pip python3-dev python3-pip If you're using an older version Ubuntu you must use: sudo apt-get install python-dev python-pip python3-dev sudo apt-get install python3-setuptools sudo easy_install3 pip For instructions to install the Python modules, see [ :help provider-python ]. If you want to use Neovim for some (or all) of the editor alternatives, use the following commands: sudo update-alternatives --install /usr/bin/vi vi /usr/bin/nvim 60 sudo update-alternatives --config vi sudo update-alternatives --install /usr/bin/vim vim /usr/bin/nvim 60 sudo update-alternatives --config vim sudo update-alternatives --install /usr/bin/editor editor /usr/bin/nvim 60 sudo update-alternatives --config editor Note, however, that special interfaces, like view for nvim -R , are not supported. (See #1646 and #2008 .) Void-Linux Neovim can be installed using the xbps package manager sudo xbps-install -S neovim BSD FreeBSD Neovim can be installed using pkg(8) : pkg install neovim or from the ports tree : cd /usr/ports/editors/neovim/ && make install clean To install the pynvim Python modules using pkg(8) run: pkg install py27-pynvim py36-pynvim OpenBSD Neovim can be installed using pkg_add(1) : pkg_add neovim or from the ports tree : cd /usr/ports/editors/neovim/ && make install Android Termux on the Google Play store offers a Neovim package. Install from source If a package is not provided for your platform, you can build Neovim from source. See Building-Neovim for details. If you have the prerequisites then building is easy: make CMAKE_BUILD_TYPE=Release sudo make install For Unix-like systems this installs Neovim to /usr/local , while for Windows to C:\\Program Files . Note, however, that this can complicate uninstallation. The following example avoids this by isolating an installation under $HOME/neovim : rm -r build/ # clear the CMake cache make CMAKE_EXTRA_FLAGS=\"-DCMAKE_INSTALL_PREFIX=$HOME/neovim\" make install export PATH=\"$HOME/neovim/bin:$PATH\" Uninstall To uninstall after make install , just delete the CMAKE_INSTALL_PREFIX artifacts: sudo rm /usr/local/bin/nvim sudo rm -r /usr/local/share/nvim/","title":"Installing-Neovim"},{"location":"Installing-Neovim/#install-from-download","text":"Downloads are available on the Releases page. Latest stable release Latest development prerelease","title":"Install from download"},{"location":"Installing-Neovim/#install-from-package","text":"Packages are listed below. (You can also build Neovim from source .)","title":"Install from package"},{"location":"Installing-Neovim/#windows","text":"","title":"Windows"},{"location":"Installing-Neovim/#chocolatey","text":"Release (v0.3): choco install neovim (use -y for automatically skipping confirmation messages) Development (pre-release): choco install neovim --pre","title":"Chocolatey"},{"location":"Installing-Neovim/#scoop","text":"Release: scoop install neovim Development (pre-release): scoop bucket add versions scoop install neovim-nightly","title":"Scoop"},{"location":"Installing-Neovim/#pre-built-archives","text":"If you are missing VCRUNTIME140.dll , install the Visual Studio 2015 C++ redistributable (choose x86_64 or x86 depending on your system). Choose a package ( nvim-winXX.zip ) from the releases page . Unzip the package. Any location is fine, administrator privileges are not required. $VIMRUNTIME will be set to that location automatically. Double-click nvim-qt.exe . Optional steps: Add the bin folder (e.g. C:\\Program Files\\nvim\\bin ) to your PATH. This makes it easy to run nvim and nvim-qt from anywhere. If :set spell does not work, create the C:/Users/foo/AppData/Local/nvim/site/spell folder. You can then copy your spell files over (for English, located here and here ); For Python plugins you need the pynvim module. \"Virtual envs\" are recommended. After activating the virtual env do pip install pynvim (in both ). Edit your init.vim so that it contains the path to the env's Python executable: let g :python3_host_prog = 'C:/Users/foo/Envs/neovim3/Scripts/python.exe' let g :python_host_prog = 'C:/Users/foo/Envs/neovim/Scripts/python.exe' Run :checkhealth and read :help provider-python . init.vim (\"vimrc\"): If you already have Vim installed you can copy %userprofile%\\_vimrc to %userprofile%\\AppData\\Local\\nvim\\init.vim to use your Vim config with Neovim.","title":"Pre-built archives"},{"location":"Installing-Neovim/#macos-os-x","text":"","title":"macOS / OS X"},{"location":"Installing-Neovim/#pre-built-archives_1","text":"The Releases page provides pre-built binaries for macOS 10.11+. curl -LO https://github.com/neovim/neovim/releases/download/nightly/nvim-macos.tar.gz tar xzf nvim-macos.tar.gz ./nvim-osx64/bin/nvim","title":"Pre-built archives"},{"location":"Installing-Neovim/#homebrew-macos-linuxbrew-linux","text":"brew install neovim Or install the development version of Nvim: brew install --HEAD neovim","title":"Homebrew (macOS) / Linuxbrew (Linux)"},{"location":"Installing-Neovim/#macports","text":"sudo port selfupdate sudo port install neovim","title":"Macports"},{"location":"Installing-Neovim/#linux","text":"","title":"Linux"},{"location":"Installing-Neovim/#appimage-universal-linux-package","text":"The Releases page provides an AppImage that runs on most Linux systems. No installation is needed, just download nvim.appimage and run it. (It might not work if your Linux distribution is more than 4 years old.) curl -LO https://github.com/neovim/neovim/releases/download/stable/nvim.appimage chmod u+x nvim.appimage ./nvim.appimage","title":"AppImage (\"universal\" Linux package)"},{"location":"Installing-Neovim/#arch-linux","text":"Neovim can be installed from the community repository: sudo pacman -S neovim Alternatively, Neovim can be also installed using the PKGBUILD neovim-git , available on the AUR . Alternatively, Neovim Nightly builds can be also installed using the PKGBUILD neovim-nightly , available on the AUR . The Python module is available from the community repository: sudo pacman -S python-pynvim Python 2 and Ruby modules (currently only supported in neovim-git ) are available from the AUR as python2-neovim and ruby-neovim respectively.","title":"Arch Linux"},{"location":"Installing-Neovim/#centos-7-rhel-7","text":"Neovim is available through EPEL (Extra Packages for Enterprise Linux) yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm yum install -y neovim python3-neovim # you might need python2-neovim as well on older Fedora releases","title":"CentOS 7 / RHEL 7"},{"location":"Installing-Neovim/#clear-linux-os","text":"NeoVim is available through the neovim bundle sudo swupd bundle-add neovim Python ( :python ) support is available if the python-basic bundle is installed. sudo swupd bundle-add python-basic","title":"Clear Linux OS"},{"location":"Installing-Neovim/#crux","text":"A CRUX port is available under 6c37/neovim , along with ports for other dependencies of Neovim. For instructions on how to install the Python modules, see [ :help provider-python ].","title":"CRUX"},{"location":"Installing-Neovim/#debian","text":"Neovim is in Debian . sudo apt-get install neovim Python ( :python ) support is installable via the package manager on Debian unstable. sudo apt-get install python-neovim sudo apt-get install python3-neovim","title":"Debian"},{"location":"Installing-Neovim/#exherbo-linux","text":"Exhereses for scm and released versions are currently available in repository ::medvid . Python client (with GTK+ GUI included) and Qt5 GUI are also available as suggestions: cave resolve app-editors/neovim --take dev-python/neovim-python --take app-editors/neovim-qt","title":"Exherbo Linux"},{"location":"Installing-Neovim/#fedora","text":"Neovim is in Fedora starting with Fedora 25: dnf install -y neovim python{2,3}-neovim You can also get nightly builds of git master from the Copr automated build system : dnf copr enable agriffis/neovim-nightly dnf install -y neovim python{2,3}-neovim See the blog post for information on how these are built.","title":"Fedora"},{"location":"Installing-Neovim/#flatpak","text":"You can find Neovim on Flathub . Providing you have Flatpak set up : flatpak install flathub io.neovim.nvim flatpak run io.neovim.nvim You can add /var/lib/flatpak/exports/bin (or ~/.local/share/flatpak/exports/bin if you used --user ) to the $PATH and run it with io.neovim.nvim . Note that Flatpak'ed Neovim will look for init.vim in ~/.var/app/io.neovim.nvim/config/nvim instead of ~/.config/nvim .","title":"Flatpak"},{"location":"Installing-Neovim/#gentoo-linux","text":"An ebuild is available in Gentoo's official portage repository: emerge -a app-editors/neovim","title":"Gentoo Linux"},{"location":"Installing-Neovim/#gnu-guix","text":"Neovim can be installed with: guix install neovim","title":"GNU Guix"},{"location":"Installing-Neovim/#nix-nixos","text":"Neovim can be installed with: nix-env -iA nixpkgs.neovim To install the Python modules: nix-env -iA nixpkgs.python3Packages.pynvim Replace python3 with python2 for the python 2 packages.","title":"Nix / NixOS"},{"location":"Installing-Neovim/#mageia-7","text":"urpmi neovim To install the Python modules: urpmi python2-pynvim python3-pynvim","title":"Mageia 7"},{"location":"Installing-Neovim/#opensuse","text":"Neovim can be installed with: sudo zypper in neovim To install the Python modules: sudo zypper in python-neovim python3-neovim","title":"OpenSUSE"},{"location":"Installing-Neovim/#pld-linux","text":"Neovim is in PLD Linux : poldek -u neovim poldek -u python-neovim python3-neovim poldek -u python-neovim-gui python3-neovim-gui","title":"PLD Linux"},{"location":"Installing-Neovim/#slackware","text":"See neovim on SlackBuilds . For instructions on how to install the Python modules, see [ :help provider-python ].","title":"Slackware"},{"location":"Installing-Neovim/#source-mage","text":"Neovim can be installed using the Sorcery package manager: cast neovim","title":"Source Mage"},{"location":"Installing-Neovim/#solus","text":"Neovim can be installed using the default package manager in Solus (eopkg): sudo eopkg install neovim","title":"Solus"},{"location":"Installing-Neovim/#snap","text":"Neovim nightly and stable are available on the snap store . Stable Builds sudo snap install --candidate nvim --classic Nightly Builds sudo snap install --edge nvim --classic","title":"Snap"},{"location":"Installing-Neovim/#ubuntu","text":"Since 18.04 As in Debian, Neovim is in Ubuntu . sudo apt install neovim Python ( :python ) support seems to be automatically installed sudo apt install python-neovim sudo apt install python3-neovim Before 18.04 Neovim has been added to a \"Personal Package Archive\" (PPA). This allows you to install it with apt-get . Follow the links to the PPAs to see which versions of Ubuntu are currently available via the PPA. Choose stable or unstable : https://launchpad.net/~neovim-ppa/+archive/ubuntu/ stable (Xenial 16.04 or newer only). https://launchpad.net/~neovim-ppa/+archive/ubuntu/ unstable To be able to use add-apt-repository you may need to install software-properties-common: sudo apt-get install software-properties-common If you're using an older version Ubuntu you must use: sudo apt-get install python-software-properties Run the following commands: sudo add-apt-repository ppa:neovim-ppa/stable sudo apt-get update sudo apt-get install neovim Prerequisites for the Python modules: sudo apt-get install python-dev python-pip python3-dev python3-pip If you're using an older version Ubuntu you must use: sudo apt-get install python-dev python-pip python3-dev sudo apt-get install python3-setuptools sudo easy_install3 pip For instructions to install the Python modules, see [ :help provider-python ]. If you want to use Neovim for some (or all) of the editor alternatives, use the following commands: sudo update-alternatives --install /usr/bin/vi vi /usr/bin/nvim 60 sudo update-alternatives --config vi sudo update-alternatives --install /usr/bin/vim vim /usr/bin/nvim 60 sudo update-alternatives --config vim sudo update-alternatives --install /usr/bin/editor editor /usr/bin/nvim 60 sudo update-alternatives --config editor Note, however, that special interfaces, like view for nvim -R , are not supported. (See #1646 and #2008 .)","title":"Ubuntu"},{"location":"Installing-Neovim/#void-linux","text":"Neovim can be installed using the xbps package manager sudo xbps-install -S neovim","title":"Void-Linux"},{"location":"Installing-Neovim/#bsd","text":"","title":"BSD"},{"location":"Installing-Neovim/#freebsd","text":"Neovim can be installed using pkg(8) : pkg install neovim or from the ports tree : cd /usr/ports/editors/neovim/ && make install clean To install the pynvim Python modules using pkg(8) run: pkg install py27-pynvim py36-pynvim","title":"FreeBSD"},{"location":"Installing-Neovim/#openbsd","text":"Neovim can be installed using pkg_add(1) : pkg_add neovim or from the ports tree : cd /usr/ports/editors/neovim/ && make install","title":"OpenBSD"},{"location":"Installing-Neovim/#android","text":"Termux on the Google Play store offers a Neovim package.","title":"Android"},{"location":"Installing-Neovim/#install-from-source","text":"If a package is not provided for your platform, you can build Neovim from source. See Building-Neovim for details. If you have the prerequisites then building is easy: make CMAKE_BUILD_TYPE=Release sudo make install For Unix-like systems this installs Neovim to /usr/local , while for Windows to C:\\Program Files . Note, however, that this can complicate uninstallation. The following example avoids this by isolating an installation under $HOME/neovim : rm -r build/ # clear the CMake cache make CMAKE_EXTRA_FLAGS=\"-DCMAKE_INSTALL_PREFIX=$HOME/neovim\" make install export PATH=\"$HOME/neovim/bin:$PATH\"","title":"Install from source"},{"location":"Installing-Neovim/#uninstall","text":"To uninstall after make install , just delete the CMAKE_INSTALL_PREFIX artifacts: sudo rm /usr/local/bin/nvim sudo rm -r /usr/local/share/nvim/","title":"Uninstall"},{"location":"Integer-types-refactoring-guidelines/","text":"Introduction In many different tasks, the need arises to refactor integer types, mainly to: - avoid errors because of mixing of signed/unsigned types and implicit conversions. - emphasize size semantics where appropriate. - conform with system functions returning size_t values without the need of casting. - ensure no unneeded limits are imposed on sizes of things we can operate on. - avoid possible data truncation because of explicit casting. - etc. It's important to agree on how this kind of refactoring should be done. However: This is a difficult thing to get completely right. No hard-and-fast set of rules will match every possible situation. This set of guidelines intends to be a framework establishing principles to help new people to confront these problems, and for more experienced people to have a consensus so that code is homogeneous. It does not intend to be a set of mechanical rules to be applied without further thinking, or to be dogmatic about . Every particular case should be carefully analyzed before taking actions on it. That said, here goes the advice: Long types long_u with size semantics (all, or mostly all) \u2192 size_t long_u without size semantics (rare, if ever) \u2192 uint64_t long with size semantics: signedness conversion easy \u2192 size_t (check for signedness conversion usual problems). signedness conversion difficult \u2192 ssize (for example, complicated code involving subtractions) Note: ssize is a project-wide typedef defined in src/nvim/types.h . long without size semantics \u2192 int64_t Int types int with size semantics: signedness conversion easy \u2192 size_t (check for signedness conversion usual problems). signedness conversion difficult \u2192 ssize (for example, complicated code involving subtractions) int without size semantics \u2192 int Special cases In spite of the general advice above, there are some cases where we prefer more tight typing. Struct fields We should try to keep structs small, if possible. To that end: - Use fixed width types ( int32_t , uint32_t , etc.), if possible. This is: - Do that only if you can be sure that the specified width will always be enough. So: - Please don't impose arbitrary/unneeded limits on fields. - For example: If a field has clear size semantics and there's no particular reason to impose a restriction on it, use size_t / ssize . External interfaces For functions interfacing other processes over a transport/serialization mechanism, fixed-width types are preferred. For example, in msgpack_rpc.h : ```c bool msgpack_rpc_integer_result(uint32_t result, msgpack_object *req, msgpack_packer *res); - For functions part of a public API, native types are preferred. For example, in a hypothetical `libneovim.h`: ```c int neovim_get_current_buffer(void); Type cascading Once you have some input variable you have to deal with (be it a struct field, a function parameter, or even a global), the issue arises whether to cascade that type in code dealing with it, or using a wider type if considered better for some reason. Typical example is, once you have a fixed-width struct field, code dealing with it (function variables/parameters) should also use fixed-width types, or could types we widened to some other enclosing type? In principle, we say: - If access to input variable is read-only, then it's safe to use wider types if some other reason makes them preferable, as you will be only upcasting the value. - If access to input variable can be read/write, then intermediate variables/params should try to maintain input variable's type as much as possible. If not, you will end up with a downcast somewhere that will require an assert/some other kind of guard/error handling. Loops We find this pretty convincing, taking great care not to incurr in errors described here . From that, we conclude: In loops, we have a counter variable and a limit expression ( condition being a comparison between counter and limit ). Issues can arise mainly because of implicit conversions in limit expression, as well as mixing different-signedness types in condition (i.e., when counter and limit have types of different signedness). To avoid/reduce implicit conversion and type-signedness-mixing problems: If possible, try to avoid different-signedness types in variables within limit expression (many errors are because implicit conversion from signed type to unsigned one). In principle, limit expression's type determines counter 's type. If limit expression is size_t , so is counter. If limit expression is ssize , so is counter. And so on. If resulting type of counter and limit is unsigned: Check limit expression for frontier values (e.g., when size is zero). Avoid condition using substractions (unless guarded so that it can be proved for result to always be positive). Prefer equivalent condition using additions on the other side. As an optimization, you could use plain int instead of ssize , or unsigned int instead of size_t , but only if you are sure that those types will be enough always. Please try not to impose arbitrary/unneeded limits.","title":"Integer-types-refactoring-guidelines"},{"location":"Integer-types-refactoring-guidelines/#introduction","text":"In many different tasks, the need arises to refactor integer types, mainly to: - avoid errors because of mixing of signed/unsigned types and implicit conversions. - emphasize size semantics where appropriate. - conform with system functions returning size_t values without the need of casting. - ensure no unneeded limits are imposed on sizes of things we can operate on. - avoid possible data truncation because of explicit casting. - etc. It's important to agree on how this kind of refactoring should be done. However: This is a difficult thing to get completely right. No hard-and-fast set of rules will match every possible situation. This set of guidelines intends to be a framework establishing principles to help new people to confront these problems, and for more experienced people to have a consensus so that code is homogeneous. It does not intend to be a set of mechanical rules to be applied without further thinking, or to be dogmatic about . Every particular case should be carefully analyzed before taking actions on it. That said, here goes the advice:","title":"Introduction"},{"location":"Integer-types-refactoring-guidelines/#long-types","text":"long_u with size semantics (all, or mostly all) \u2192 size_t long_u without size semantics (rare, if ever) \u2192 uint64_t long with size semantics: signedness conversion easy \u2192 size_t (check for signedness conversion usual problems). signedness conversion difficult \u2192 ssize (for example, complicated code involving subtractions) Note: ssize is a project-wide typedef defined in src/nvim/types.h . long without size semantics \u2192 int64_t","title":"Long types"},{"location":"Integer-types-refactoring-guidelines/#int-types","text":"int with size semantics: signedness conversion easy \u2192 size_t (check for signedness conversion usual problems). signedness conversion difficult \u2192 ssize (for example, complicated code involving subtractions) int without size semantics \u2192 int","title":"Int types"},{"location":"Integer-types-refactoring-guidelines/#special-cases","text":"In spite of the general advice above, there are some cases where we prefer more tight typing.","title":"Special cases"},{"location":"Integer-types-refactoring-guidelines/#struct-fields","text":"We should try to keep structs small, if possible. To that end: - Use fixed width types ( int32_t , uint32_t , etc.), if possible. This is: - Do that only if you can be sure that the specified width will always be enough. So: - Please don't impose arbitrary/unneeded limits on fields. - For example: If a field has clear size semantics and there's no particular reason to impose a restriction on it, use size_t / ssize .","title":"Struct fields"},{"location":"Integer-types-refactoring-guidelines/#external-interfaces","text":"For functions interfacing other processes over a transport/serialization mechanism, fixed-width types are preferred. For example, in msgpack_rpc.h : ```c bool msgpack_rpc_integer_result(uint32_t result, msgpack_object *req, msgpack_packer *res); - For functions part of a public API, native types are preferred. For example, in a hypothetical `libneovim.h`: ```c int neovim_get_current_buffer(void);","title":"External interfaces"},{"location":"Integer-types-refactoring-guidelines/#type-cascading","text":"Once you have some input variable you have to deal with (be it a struct field, a function parameter, or even a global), the issue arises whether to cascade that type in code dealing with it, or using a wider type if considered better for some reason. Typical example is, once you have a fixed-width struct field, code dealing with it (function variables/parameters) should also use fixed-width types, or could types we widened to some other enclosing type? In principle, we say: - If access to input variable is read-only, then it's safe to use wider types if some other reason makes them preferable, as you will be only upcasting the value. - If access to input variable can be read/write, then intermediate variables/params should try to maintain input variable's type as much as possible. If not, you will end up with a downcast somewhere that will require an assert/some other kind of guard/error handling.","title":"Type cascading"},{"location":"Integer-types-refactoring-guidelines/#loops","text":"We find this pretty convincing, taking great care not to incurr in errors described here . From that, we conclude: In loops, we have a counter variable and a limit expression ( condition being a comparison between counter and limit ). Issues can arise mainly because of implicit conversions in limit expression, as well as mixing different-signedness types in condition (i.e., when counter and limit have types of different signedness). To avoid/reduce implicit conversion and type-signedness-mixing problems: If possible, try to avoid different-signedness types in variables within limit expression (many errors are because implicit conversion from signed type to unsigned one). In principle, limit expression's type determines counter 's type. If limit expression is size_t , so is counter. If limit expression is ssize , so is counter. And so on. If resulting type of counter and limit is unsigned: Check limit expression for frontier values (e.g., when size is zero). Avoid condition using substractions (unless guarded so that it can be proved for result to always be positive). Prefer equivalent condition using additions on the other side. As an optimization, you could use plain int instead of ssize , or unsigned int instead of size_t , but only if you are sure that those types will be enough always. Please try not to impose arbitrary/unneeded limits.","title":"Loops"},{"location":"Introduction/","text":"Vim is a powerful text editor with a big community that is constantly growing. Even though the editor is about two decades old, people still extend and want to improve it, mostly using Vimscript or one of the supported scripting languages. Motivation Over its more than 20 years of life, Vim has accumulated about 300k lines of scary C89 code that very few people understand or have the guts to mess with. Another issue is that as the only person responsible for maintaining Vim's big codebase, Bram Moolenaar, has to be extra careful before accepting patches, because, once merged, the new code will be his responsibility. These problems make it very difficult to have new features and bug fixes merged into the core. Vim just can't keep up with the development speed of its plugin ecosystem. Solution Neovim is a project that seeks to aggressively refactor Vim source code in order to achieve the following goals: Simplify maintenance to improve the speed that bug fixes and features get merged. Split the work among multiple developers. Enable the implementation of new/modern user interfaces without any modifications to the core source. Improve the extensibility power with a new plugin architecture based on coprocesses. Plugins will be written in any programming language without any explicit support from the editor. By achieving those goals new developers will soon join the community, consequently improving the editor for all users. It is important to emphasize that this is not a project to rewrite Vim from scratch or transform it into an IDE (though the new features provided will enable IDE-like distributions of the editor). The changes implemented here should have little impact on Vim's editing model or Vimscript in general. Most Vimscript plugins should continue to work normally. The following topics contain brief explanations of the major changes (and motivations) that will be performed in the first iteration. Migrate to a CMake-based build The source tree has dozens (if not hundreds) of files dedicated to building Vim on various platforms with different configurations, and many of these files look abandoned or outdated. Most users don't care about selecting individual features and just compile using --with-features=huge , which still generates an executable that is small enough even for lightweight systems by today's standards. All those files will be removed and Vim will be built using CMake , a modern build system that generates build scripts for the most relevant platforms. Legacy support and compile-time features Vim has a significant amount of code dedicated to supporting legacy systems and compilers. All that code increases the maintenance burden and will be removed. Most optional features will no longer be optional (see above), with the exception of some broken and useless features (e.g. NetBeans and Sun WorkShop integration) which will be removed permanently. Vi emulation will also be removed (setting nocompatible will be a no-op). Platform-specific code Most of the platform-specific code will be removed and libuv will be used to handle system differences. libuv is a modern multi-platform library with functions to perform common system tasks, and supports most unixes and Windows, so the vast majority of Vim's community will be covered. New plugin architecture All code supporting embedded scripting language interpreters will be replaced by a new plugin system that supports extensions written in any programming language. Compatibility layers will be provided for legacy Vim plugins written in some of the currently supported scripting languages such as Python or Ruby. Most plugins should work on Neovim with little modification, if any. Moreover, GUIs are implemented as plugins, decoupled from the Neovim core. See the Plugin Architecture page for a detailed overview.","title":"Introduction"},{"location":"Introduction/#motivation","text":"Over its more than 20 years of life, Vim has accumulated about 300k lines of scary C89 code that very few people understand or have the guts to mess with. Another issue is that as the only person responsible for maintaining Vim's big codebase, Bram Moolenaar, has to be extra careful before accepting patches, because, once merged, the new code will be his responsibility. These problems make it very difficult to have new features and bug fixes merged into the core. Vim just can't keep up with the development speed of its plugin ecosystem.","title":"Motivation"},{"location":"Introduction/#solution","text":"Neovim is a project that seeks to aggressively refactor Vim source code in order to achieve the following goals: Simplify maintenance to improve the speed that bug fixes and features get merged. Split the work among multiple developers. Enable the implementation of new/modern user interfaces without any modifications to the core source. Improve the extensibility power with a new plugin architecture based on coprocesses. Plugins will be written in any programming language without any explicit support from the editor. By achieving those goals new developers will soon join the community, consequently improving the editor for all users. It is important to emphasize that this is not a project to rewrite Vim from scratch or transform it into an IDE (though the new features provided will enable IDE-like distributions of the editor). The changes implemented here should have little impact on Vim's editing model or Vimscript in general. Most Vimscript plugins should continue to work normally. The following topics contain brief explanations of the major changes (and motivations) that will be performed in the first iteration.","title":"Solution"},{"location":"Introduction/#migrate-to-a-cmake-based-build","text":"The source tree has dozens (if not hundreds) of files dedicated to building Vim on various platforms with different configurations, and many of these files look abandoned or outdated. Most users don't care about selecting individual features and just compile using --with-features=huge , which still generates an executable that is small enough even for lightweight systems by today's standards. All those files will be removed and Vim will be built using CMake , a modern build system that generates build scripts for the most relevant platforms.","title":"Migrate to a CMake-based build"},{"location":"Introduction/#legacy-support-and-compile-time-features","text":"Vim has a significant amount of code dedicated to supporting legacy systems and compilers. All that code increases the maintenance burden and will be removed. Most optional features will no longer be optional (see above), with the exception of some broken and useless features (e.g. NetBeans and Sun WorkShop integration) which will be removed permanently. Vi emulation will also be removed (setting nocompatible will be a no-op).","title":"Legacy support and compile-time features"},{"location":"Introduction/#platform-specific-code","text":"Most of the platform-specific code will be removed and libuv will be used to handle system differences. libuv is a modern multi-platform library with functions to perform common system tasks, and supports most unixes and Windows, so the vast majority of Vim's community will be covered.","title":"Platform-specific code"},{"location":"Introduction/#new-plugin-architecture","text":"All code supporting embedded scripting language interpreters will be replaced by a new plugin system that supports extensions written in any programming language. Compatibility layers will be provided for legacy Vim plugins written in some of the currently supported scripting languages such as Python or Ruby. Most plugins should work on Neovim with little modification, if any. Moreover, GUIs are implemented as plugins, decoupled from the Neovim core. See the Plugin Architecture page for a detailed overview.","title":"New plugin architecture"},{"location":"List-management-in-Neovim/","text":"Management of lists (types list_T and listitem_T from vim) was changed in https://github.com/neovim/neovim/pull/7708/ . There is a lint against the \"old\" usage, but here is a list (pun not intended) of the most important changes. Declarations for the table list_T list : a list listitem_T li : an item of list int val a value for lv_copyID Old New Comment list->lv_first tv_list_first(list) list->lv_last tv_list_last(list) li->li_next TV_LIST_ITEM_NEXT(list, li) To be avoided if possible, must use list which li belongs to. li->li_prev TV_LIST_ITEM_PREV(list, li) To be avoided if possible, must use list which li belongs to. Suggestion by @ZyX-l: Use TV_LIST_ITER or indexing instead of the previous two calls. list->lv_len tv_list_len(list) list->lv_lock tv_list_locked(list) &li->li_tv TV_LIST_ITEM_TV(li) list->lv_refcount++ tv_list_ref(list) val = list->lv_copyID val = tv_list_copyid(list) list->lv_copyID = val tv_list_set_copyid(list, val) for (li = list->lv_first; li != NULL && another_cond; li = li->li_next) code TV_LIST_ITER_CONST(list, li, { if (another_cond) {break;} code}) Use TV_LIST_ITER(\u2026) if you need to modify list items (note: assigning copyID is also modification and this happens always when recursively traversing a list). For more details and some more advanced usage, the doxygen documentation on typval.h and typval.c .","title":"List-management-in-Neovim"},{"location":"Merging-patches-from-upstream-Vim/","text":"See Quickstart to get started immediately. Also note the section on Not Applicable patches. Neovim was forked from Vim 7.4.160; it is kept up-to-date with relevant Vim patches in order to avoid duplicate work. Run vim-patch.sh to see the status of Vim patches: ./scripts/vim-patch.sh -l Everyone is welcome to send pull requests for relevant Vim patches, but some types of patches are not applicable . Quickstart Pull down the Neovim source: git clone https://github.com/neovim/neovim.git Run ./scripts/vim-patch.sh -l to see the list of missing Vim patches. Choose a patch from the list (usually the oldest one), e.g. 8.0.0123 . Check for open vim-patch PRs . Run ./scripts/vim-patch.sh -p 8.0.0123 Follow the instructions given by the script. Notes It's strongly recommended to work on the oldest missing patch, because later patches might depend on the changes. Use git log -G to search the Nvim/Vim source history (even deleted code). E.g. to find reset_option_was_set : git log -p -G reset_option_was_set Pull requests Note: vim-patch.sh automates these steps for you. Use it! Install hub or git-hub if you want to use vim-patch.sh to create PRs automatically There should be a configuration file ~/.config/hub when you are using 2FA in GitHub The pull request title should include vim-patch:8.0.xxxx (no whitespace) The commit message should include: A token indicating the Vim patch number, formatted as follows: vim-patch:8.0.0123 (no whitespace) A URL pointing to the Vim commit: https://github.com/vim/vim/commit/c8020ee825b9d9196b1329c0e097424576fc9b3a The original Vim commit message, including author Reviewers: hint for reviewing runtime/ patches NA (\"Not Applicable\") patches Many Vim patches are not applicable to Neovim. If you find NA patches, visit the \"version.c: update\" pull request and mention the NA patches in a comment (please edit/update one comment, rather than adding a new comment for each patch). If you are working on a series of patches, you may notice some \"Not Applicable\" patches. In that case you may want to mark the NA patches a commit message, using this format exactly (each patch on a separate line): vim-patch:<version-or-commit> vim-patch:<version-or-commit> ... where <version-or-commit> is a valid Vim version (like 8.0.0123 ) or commit-id (SHA). Types of \"Not Applicable\" Vim patches: Updates to testdir/Makefile are usually NA because the Makefile implicitly finds all test_*.vim files. Compiler warning fixes : Neovim strives to have no warnings at all, and has a very different build system from Vim. Note: Coverity fixes in Vim are relevant to Neovim. #ifdef tweaking : For example, Vim decided to enable FEAT_VISUAL for all platforms \u2014 but Neovim already does that. Adding new FEAT_ guards also isn't relevant to Neovim. Legacy system support : Fixes for legacy systems such as Amiga, OS/2 Xenix, Mac OS 9, Windows older than XP SP2, are not needed because they are not supported by Neovim. if_*.c changes: if_python.c et. al. were removed. term.c changes: the Neovim TUI uses libtermkey to read terminal sequences; Vim's term.c was removed. :terminal patches defaults.vim patches Most GUI-related changes: Neovim GUIs are implemented external to the core C codebase. Anything else might be relevant; err on the side of caution, and post an issue if you aren't sure. version.c The list of Vim patches in src/nvim/version.c is automatically updated based on the presence of vim-patch:xxx tokens in the Neovim git log. Don't update src/nvim/version.c yourself. scripts/vim-patch.sh -p intentionally omits version.c to avoid merge conflicts and save time when porting a patch. The automation script ( scripts/vimpatch.lua ) only recognizes tokens like vim-patch:8.0.1206 , not vim-patch:<hash> . Code differences The following functions have been removed or deprecated in favor of newer alternatives. See the memory.c Doxygen page for more information. Deprecated or removed Replacement vim_free xfree VIM_CLEAR(&foo) XFREE_CLEAR(foo) malloc alloc lalloc lalloc_id xmalloc calloc lalloc_clear xcalloc realloc vim_realloc xrealloc mch_memmove memmove vim_memset copy_chars copy_spaces memset vim_strncpy strncpy xstrlcpy vim_strcat strncat xstrlcat vim_islower vim_isupper mb_islower mb_isupper vim_tolower vim_toupper mb_tolower mb_toupper mb_ptr2len utfc_ptr2len mb_ptr2len_len utfc_ptr2len_len mb_char2len utf_char2len mb_char2bytes utf_char2bytes mb_ptr2cells utf_ptr2cells mb_ptr2cells_len utf_ptr2cells_len mb_char2cells utf_char2cells mb_off2cells utf_off2cells mb_ptr2char utf_ptr2char mb_head_off utf_head_off mb_lefthalve grid_lefthalve mb_fix_col grid_fix_col utf_off2cells grid_off2cells screen_char ui_line screen_line grid_put_linebuf screen_* (most functions) grid_* update_prepare , update_finish #9484 removed; use update_screen only Make sure to note the difference between utf_ and utfc_ when replacing mb_ functions. Also indirect call syntax (*mb_ptr2len)(...) should be replaced with an ordinary function call utfc_ptr2len(...) . Data type Format (Vim source) Portable format (Nvim source) long long \"%lld\" \"%\" PRId64 size_t \"%ld\" \"%zu\" See also: https://github.com/neovim/neovim/pull/1729#discussion_r22423779 Vim's ga_init2 was renamed to ga_init and the original ga_init is gone. \"Old style\" Vim tests ( src/testdir/*.in ) should be converted to Lua tests (see #1286 and #1328 ). See Checklist for migrating legacy tests . However, please do not convert \"new style\" Vim tests ( src/testdir/*.vim ) to Lua. The \"new style\" Vim tests are faster than the old ones, and converting them takes time and effort better spent elsewhere. Just copy them to src/nvim/testdir/*.vim and update src/nvim/testdir/Makefile . Conditions that check enc_utf8 or has_mbyte are obsolete (only the \"true\" case is applicable). List management has changed in Neovim, see this wiki page . Documentation differences The following should be removed from all imported documentation, and not be used in new documentation: {not in Vi} : we don't care about compatibility with Vi (see 818f7ae ). {Only when compiled with ...} - the vast majority of features have been made non-optional (see Introduction )","title":"Merging-patches-from-upstream-Vim"},{"location":"Merging-patches-from-upstream-Vim/#quickstart","text":"Pull down the Neovim source: git clone https://github.com/neovim/neovim.git Run ./scripts/vim-patch.sh -l to see the list of missing Vim patches. Choose a patch from the list (usually the oldest one), e.g. 8.0.0123 . Check for open vim-patch PRs . Run ./scripts/vim-patch.sh -p 8.0.0123 Follow the instructions given by the script.","title":"Quickstart"},{"location":"Merging-patches-from-upstream-Vim/#notes","text":"It's strongly recommended to work on the oldest missing patch, because later patches might depend on the changes. Use git log -G to search the Nvim/Vim source history (even deleted code). E.g. to find reset_option_was_set : git log -p -G reset_option_was_set","title":"Notes"},{"location":"Merging-patches-from-upstream-Vim/#pull-requests","text":"Note: vim-patch.sh automates these steps for you. Use it! Install hub or git-hub if you want to use vim-patch.sh to create PRs automatically There should be a configuration file ~/.config/hub when you are using 2FA in GitHub The pull request title should include vim-patch:8.0.xxxx (no whitespace) The commit message should include: A token indicating the Vim patch number, formatted as follows: vim-patch:8.0.0123 (no whitespace) A URL pointing to the Vim commit: https://github.com/vim/vim/commit/c8020ee825b9d9196b1329c0e097424576fc9b3a The original Vim commit message, including author Reviewers: hint for reviewing runtime/ patches","title":"Pull requests"},{"location":"Merging-patches-from-upstream-Vim/#na-not-applicable-patches","text":"Many Vim patches are not applicable to Neovim. If you find NA patches, visit the \"version.c: update\" pull request and mention the NA patches in a comment (please edit/update one comment, rather than adding a new comment for each patch). If you are working on a series of patches, you may notice some \"Not Applicable\" patches. In that case you may want to mark the NA patches a commit message, using this format exactly (each patch on a separate line): vim-patch:<version-or-commit> vim-patch:<version-or-commit> ... where <version-or-commit> is a valid Vim version (like 8.0.0123 ) or commit-id (SHA).","title":"NA (\"Not Applicable\") patches"},{"location":"Merging-patches-from-upstream-Vim/#types-of-not-applicable-vim-patches","text":"Updates to testdir/Makefile are usually NA because the Makefile implicitly finds all test_*.vim files. Compiler warning fixes : Neovim strives to have no warnings at all, and has a very different build system from Vim. Note: Coverity fixes in Vim are relevant to Neovim. #ifdef tweaking : For example, Vim decided to enable FEAT_VISUAL for all platforms \u2014 but Neovim already does that. Adding new FEAT_ guards also isn't relevant to Neovim. Legacy system support : Fixes for legacy systems such as Amiga, OS/2 Xenix, Mac OS 9, Windows older than XP SP2, are not needed because they are not supported by Neovim. if_*.c changes: if_python.c et. al. were removed. term.c changes: the Neovim TUI uses libtermkey to read terminal sequences; Vim's term.c was removed. :terminal patches defaults.vim patches Most GUI-related changes: Neovim GUIs are implemented external to the core C codebase. Anything else might be relevant; err on the side of caution, and post an issue if you aren't sure.","title":"Types of \"Not Applicable\" Vim patches:"},{"location":"Merging-patches-from-upstream-Vim/#versionc","text":"The list of Vim patches in src/nvim/version.c is automatically updated based on the presence of vim-patch:xxx tokens in the Neovim git log. Don't update src/nvim/version.c yourself. scripts/vim-patch.sh -p intentionally omits version.c to avoid merge conflicts and save time when porting a patch. The automation script ( scripts/vimpatch.lua ) only recognizes tokens like vim-patch:8.0.1206 , not vim-patch:<hash> .","title":"version.c"},{"location":"Merging-patches-from-upstream-Vim/#code-differences","text":"The following functions have been removed or deprecated in favor of newer alternatives. See the memory.c Doxygen page for more information. Deprecated or removed Replacement vim_free xfree VIM_CLEAR(&foo) XFREE_CLEAR(foo) malloc alloc lalloc lalloc_id xmalloc calloc lalloc_clear xcalloc realloc vim_realloc xrealloc mch_memmove memmove vim_memset copy_chars copy_spaces memset vim_strncpy strncpy xstrlcpy vim_strcat strncat xstrlcat vim_islower vim_isupper mb_islower mb_isupper vim_tolower vim_toupper mb_tolower mb_toupper mb_ptr2len utfc_ptr2len mb_ptr2len_len utfc_ptr2len_len mb_char2len utf_char2len mb_char2bytes utf_char2bytes mb_ptr2cells utf_ptr2cells mb_ptr2cells_len utf_ptr2cells_len mb_char2cells utf_char2cells mb_off2cells utf_off2cells mb_ptr2char utf_ptr2char mb_head_off utf_head_off mb_lefthalve grid_lefthalve mb_fix_col grid_fix_col utf_off2cells grid_off2cells screen_char ui_line screen_line grid_put_linebuf screen_* (most functions) grid_* update_prepare , update_finish #9484 removed; use update_screen only Make sure to note the difference between utf_ and utfc_ when replacing mb_ functions. Also indirect call syntax (*mb_ptr2len)(...) should be replaced with an ordinary function call utfc_ptr2len(...) . Data type Format (Vim source) Portable format (Nvim source) long long \"%lld\" \"%\" PRId64 size_t \"%ld\" \"%zu\" See also: https://github.com/neovim/neovim/pull/1729#discussion_r22423779 Vim's ga_init2 was renamed to ga_init and the original ga_init is gone. \"Old style\" Vim tests ( src/testdir/*.in ) should be converted to Lua tests (see #1286 and #1328 ). See Checklist for migrating legacy tests . However, please do not convert \"new style\" Vim tests ( src/testdir/*.vim ) to Lua. The \"new style\" Vim tests are faster than the old ones, and converting them takes time and effort better spent elsewhere. Just copy them to src/nvim/testdir/*.vim and update src/nvim/testdir/Makefile . Conditions that check enc_utf8 or has_mbyte are obsolete (only the \"true\" case is applicable). List management has changed in Neovim, see this wiki page .","title":"Code differences"},{"location":"Merging-patches-from-upstream-Vim/#documentation-differences","text":"The following should be removed from all imported documentation, and not be used in new documentation: {not in Vi} : we don't care about compatibility with Vi (see 818f7ae ). {Only when compiled with ...} - the vast majority of features have been made non-optional (see Introduction )","title":"Documentation differences"},{"location":"Plugin-UI-architecture/","text":"A contributing factor to legacy Vim's huge codebase is its explicit support for dozens of widget toolkits for GUI interfaces. Neovim avoids that by delegating GUI implementation to external clients. The client(s) control the Neovim nvim process via a msgpack-rpc API, allowing them to: Execute Vim commands Evaluate Vimscript expressions Manipulate buffers, windows and tabs Receive/handle editor events On top of that, the remote API has been designed for easy extensibility, so there will always be new possibilities. A Neovim remote plugin ( rplugin ) is any program that talks to nvim through the remote API (which can be reached via any arbitrary transport mechanism: TCP address, named pipe, stdin/stdout, ...). It's possible to test the current API interactively using the python REPL and the client library , but that isn't very useful for extending the editor. A typical Neovim plugin will have the following pseudo code running: while true handle(next_vim_event()) If you think about it, that's pretty much how legacy Vim plugins currently work: They register autocommands to be executed whenever something interesting happens. The difference is that Neovim can also propagate events to other processes and receive commands asynchronously, and this opens some interesting possibilities for plugins: They can be written in any programming language. Modern GUIs written in high-level languages that integrate better with the operating system (e.g., C#/WPF on Windows or Ruby/Cocoa on OS X). They are sandboxed so there's less chance of the editor (server) crashing due to bugs. They can perform background work without blocking the editor They can emit custom events that may be handled directly by GUIs (enables implementation of advanced features such as Sublime's minimap). Multiple remote GUIs can attach/detach to share editing sessions. Simplified headless testing. Embedding the editor into other programs. In fact, a GUI can be seen as a program that embeds neovim. UI programs UIs are plugins that work as a bridge between the user and the editor. Here's pseudo-code of a UI program: while true handle(next_vim_or_user_event()) It's almost the same as a non-UI plugin, except they must also listen for user events (keypresses, mouse clicks, etc) and translate these to the connected Neovim instance, which then emits redraw events back to the user. Here's a sample process tree: Neovim ------> GUI 1 (attach/detach to running instance) | | | `------> GUI 2 (communicating on a different socket or transport | mechanism, but sharing the same session with GUI 1) `--> Plugin 1 | `--> Plugin 2 | `--> Plugin 3 Here's an outline of the nvim startup process: start listening on a socket or TCP address (random unless overridden) UI may be specified as a command-line argument to nvim read ~/.config/nvim/init.vim discover plugins (which may include UI) start the UI program, passing the listen address. open two-way communication channels with all plugins Here's a hypothetical GUI session: gui -> vim : { \"id\" : 1 , \"method\" : \"initClient\" , \"params\" : { \"size\" : { \"rows\" : 20 , \"columns\" : 25 }}} vim -> gui : { \"id\" : 1 , \"result\" : { \"clientId\" : 1 }} vim -> gui : { \"method\" : \"redraw\" , \"params\" : { \"clientId\" : 1 , \"lines\" : { \"5\" : \"Welcome to neovim!\" }}} gui -> vim : { \"id\" : 2 , \"method\" : \"keyPress\" , \"params\" : { \"keys\" : [ \"H\" , \"e\" , \"l\" , \"l\" , \"o\" ]}} vim -> gui : { \"method\" : \"redraw\" , \"params\" : { \"clientId\" : 1 , \"lines\" : { \"1\" : \"Hello\" , \"5\" : \"\" }}}","title":"Plugin-UI-architecture"},{"location":"Plugin-UI-architecture/#ui-programs","text":"UIs are plugins that work as a bridge between the user and the editor. Here's pseudo-code of a UI program: while true handle(next_vim_or_user_event()) It's almost the same as a non-UI plugin, except they must also listen for user events (keypresses, mouse clicks, etc) and translate these to the connected Neovim instance, which then emits redraw events back to the user. Here's a sample process tree: Neovim ------> GUI 1 (attach/detach to running instance) | | | `------> GUI 2 (communicating on a different socket or transport | mechanism, but sharing the same session with GUI 1) `--> Plugin 1 | `--> Plugin 2 | `--> Plugin 3 Here's an outline of the nvim startup process: start listening on a socket or TCP address (random unless overridden) UI may be specified as a command-line argument to nvim read ~/.config/nvim/init.vim discover plugins (which may include UI) start the UI program, passing the listen address. open two-way communication channels with all plugins Here's a hypothetical GUI session: gui -> vim : { \"id\" : 1 , \"method\" : \"initClient\" , \"params\" : { \"size\" : { \"rows\" : 20 , \"columns\" : 25 }}} vim -> gui : { \"id\" : 1 , \"result\" : { \"clientId\" : 1 }} vim -> gui : { \"method\" : \"redraw\" , \"params\" : { \"clientId\" : 1 , \"lines\" : { \"5\" : \"Welcome to neovim!\" }}} gui -> vim : { \"id\" : 2 , \"method\" : \"keyPress\" , \"params\" : { \"keys\" : [ \"H\" , \"e\" , \"l\" , \"l\" , \"o\" ]}} vim -> gui : { \"method\" : \"redraw\" , \"params\" : { \"clientId\" : 1 , \"lines\" : { \"1\" : \"Hello\" , \"5\" : \"\" }}}","title":"UI programs"},{"location":"Progress/","text":"This page is only a stub. Please update any links to point to https://neovim.io/doc/user/vim_diff.html#nvim-features instead. See the Roadmap and :help nvim-features .","title":"Progress"},{"location":"Refactor-Vim-into-a-library/","text":"Here's an idea of how Vim reads input and transitions between modes. The actual code is much more complex but follows this basic flow: while ( 1 ) { normal_mode_process_byte ( getc ()); } void normal_mode_process_byte ( char c ) { if ( c == 'i' ) // enter insert mode while ( 1 ) { insert_mode_process_byte ( getc ()); } } What needs to be done is remove all those read loops and replace by a function (e.g., process_byte(char c) ) that will buffer input, delegate to mode-specific input-handling functions or transition editor state when necessary. Something like this: void process_byte ( char c ) { if ( mode == NORMAL ) normal_mode_process_byte ( c ); else if ( mode == INSERT ) insert_mode_process_byte ( c ); ... } void normal_mode_process_byte ( char c ) { if ( c == 'i' ) { mode = INSERT ; return ; } ... } Think of the editor as a state machine: when input is read and fed into the machine, it may change the active buffer, transition mode, etc. The point is: the machine shouldn't call IO functions directly","title":"Refactor-Vim-into-a-library"},{"location":"Refactoring/","text":"Pull requests \"Cleanup\" PRs should include some unit tests that cover the function being changed, so that we can feel more confident about regressions, future changes, and Vim-patch merges. For example if the coverage report shows that build_stl_str_hl is not covered by our tests, any \"cleanup\" PR for build_stl_str_hl should include unit-test coverage. Frozen legacy modules Refactoring Vim structurally and aesthetically is an important goal of Neovim. But there are some modules that should not be changed significantly, because they are maintained only by Bram, at present. Until someone takes \"ownership\" of these modules, the cost of any significant changes (including style or structural changes that re-arrange the code) to these modules outweighs the benefit. The modules are: regexp.c regexp_nfa.c indent_c.c","title":"Refactoring"},{"location":"Refactoring/#pull-requests","text":"\"Cleanup\" PRs should include some unit tests that cover the function being changed, so that we can feel more confident about regressions, future changes, and Vim-patch merges. For example if the coverage report shows that build_stl_str_hl is not covered by our tests, any \"cleanup\" PR for build_stl_str_hl should include unit-test coverage.","title":"Pull requests"},{"location":"Refactoring/#frozen-legacy-modules","text":"Refactoring Vim structurally and aesthetically is an important goal of Neovim. But there are some modules that should not be changed significantly, because they are maintained only by Bram, at present. Until someone takes \"ownership\" of these modules, the cost of any significant changes (including style or structural changes that re-arrange the code) to these modules outweighs the benefit. The modules are: regexp.c regexp_nfa.c indent_c.c","title":"Frozen legacy modules"},{"location":"Related-projects/","text":"If you're working on a Neovim-related project, include it (alphabetically) below! Note: Some of these projects are experimental/unstable . GUI Platform Project Activity Atom Integration carlosdcastillo/vim-mode abandoned Avalonia yatli/fvim Browsers Firenvim C++/Python meatich/NeoSFML inactive C++/SDL2 etorth/libnvc curses/Python mvilim/neovim-pytc-example EFL Eovim Electron UI coolwanglu/neovim-e inactive Electron UI rhysd/NyaoVim Revery UI onivim/oni2 Electron UI onivim/oni Electron UI veonim Electron UI VV VSCode VSCodeVim VSCode Neo Vim gnome-terminal neovim-gnome-terminal-wrapper Go/Qt akiyosi/gonvim Go/Qt dzhou121/gonvim abandoned GTK/Python UI neovim/python-gui GTK/Python UI rliang/nvim-pygtk3 GTK/Rust UI daa84/neovim-gtk GTK/Rust UI GNvim JavaFX jebberjeb/javafx-neovimpane Konsole harish2704/neovim-konsole inactive macOS qvacua/vimr macOS rogual/neovim-dot-app mac OS UI DinVim Vim for Mac Terminal Wrapper glrnvim Qt 5 equalsraf/neovim-qt Qt Creator sassanh/qnvim Rust IDE oakes/SolidOak archived Sublime Text lunixbochs/actualvim Tk/Python UI timeyyy/pytknvim inactive Windows/Linux meatich/Viy inactive Note: Activity only takes into account the update of the codebase, excluding README, etc. API clients Platform Project C# neovim/nvim.net C++ DaikiMaekawa/neovim.cpp C++/Qt5 equalsraf/neovim-qt C++/ncurses SoC/neovim-client C++/Magnum Squareys/magnum-neovim-api Clojure jebberjeb/neovim-client Common Lisp adolenc/cl-neovim D viniarck/nvimhost-d Dart smolck/dart-nvim-api Elixir awetzel/neovim-elixir Filesystem fmoralesc/nvimfs Go neovim/go-client Haskell neovimhaskell/nvim-hs Java fdinoff/neovim-java-client Java esensar/neovim-java Julia bfredl/Neovim.jl Lua neovim/lua-client Node.js neovim/node-client Node.js neoclide/neovim OCaml janestreet/vcaml Perl yanick/Neovim-RPC Python neovim/pynvim R jalvesaq/Nvim-R Racket HiPhish/neovim.rkt Ruby neovim/neovim-ruby Rust oakes/neovim-rs [archived] Rust daa84/neovim-lib Scala viniarck/nvimhost-scala Swift/Cocoa NvimView (part of qvacua/vimr) Plugins The following plugins take advantage of specific Neovim features, e.g. jobstart() , :terminal or its remote plugin mechanism. acid.nvim : Asynchronous nREPL client for Clojure development aerojump.nvim : Filter as you type searcher/jumper with fuzzy matching. alchemist.vim : Elixir integration axe : Asynchronous executor for predefined custom commands bolt.nvim : Filter as you type file manager with fuzzy matching and ripgrep integration LeaderF : An asynchronous fuzzy finder which is used to quickly locate files, buffers, mrus, tags, gtags, etc. in large project. buildit.nvim : An async project builder, tries to detect the right builder for your project chromatica.nvim : Clang-based syntax highlighting coc.nvim : Completion and other language server support for Neovim, featured as VSCode Conjure : Clojure and ClojureScript tooling for Neovim over a socket prepl connection dein.vim : Plugin manager denite.nvim : Dark powered plugin for Neovim/Vim to unite all interfaces deoplete.nvim : Dark powered asynchronous completion framework Extract : Puts and yanks to a list with normal, visual swapping, and insert list/register completion far.vim : Search and replace Floobits : Floobits plugin FlyGrep.vim : Asynchronously fly grep in vim fzf-gitignore : A fzf (command-line fuzzy finder) interface for creating .gitignore files using the gitignore.io API gen_tags.vim : Async plugin for Vim and Neovim to ease the use of Ctags/gTags haskell-vim : Custom syntax highlighting and indentation Vimscripts for Haskell and Cabal InsertLeftBracket.nvim : Auto-complete brackets for Objective-C files iron.nvim : REPL management LanguageClient-neovim : Language Server Protocol (LSP) support for Neovim lldb.nvim : Debugger integration with a focus on ease-of-use markdown-preview.nvim : Preview Markdown files on your browser with synchronous scrolling; flexible configuration using Neovim's RPC API mirror.vim : Efficient way to edit remote files on multiple environments mkdx : Vim plugin that adds some nice extras for working with Markdown documents ncm2 : Slim, fast, and hackable completion framework for Neovim (fork of nvim-completion-manager) neogdb.vim : Vim GDB front-end for neovim written in python/vimscript neomake-multiprocess : Vim plugin for running multiple process asynchronously based on Neomake neomake : Asynchronous linting and make framework neopipe : Send lines of text to an external command and display output in a scratch buffer neotags.nvim : Plugin that generates and highlights Ctags neoterm : Wrapper of some Neovim's :terminal functions neotex : Latex live preview neovim-hackernews : Display Hacker News (HN) stories inside Neovim neovim-ranger : File manager with Vi key bindings neovim-vifm : Integration between Vifm (Vi file manager) and Neovim nim.nvim : Nim language support nlanguagetool.nvim : Integration with LanguageTool, a style and grammar checker for natural languages nuake : Quake-style terminal panel for Neovim nvim-completion-manager (deprecated): Fast, extensible, asynchronous completion framework nvim-editcommand : Edit your current shell command inside a scratch buffer nvim-gdb : Neovim thin wrapper for GDB, LLDB and PDB written in Moonscript/Lua nvim-go : Go development plugin for Neovim written in pure Go nvim-ipy : IPython/Jupyter integration nvim-luadev : REPL for developing lua plugins nvim-miniyank : Simple yankring (shared across instances) nvim-marksman - A file finder that minimizes the amount of keystrokes needed to go to a file nvim-moonmaker : Adds plugin support for MoonScript files in the same way the built-in support for Lua/Python files works (by automatically compiling MoonScript files to Lua) nvim-palette : Fuzzy search of settings Nvim-R : Plugin to work with R nvim-terminus : Edit your current command in a scratch buffer nvim-typescript : Asynchronous typescript tooling and completion nvimpam : Provides async folding for Pam-Crash files nvimux : Neovim as multiplexer with tmux keybindings orchestra.nvim : Bind sound effects to different actions proteome : Assists in working on multiple projects in a single Neovim instance semshi : Semantic highlighting for Python termedit.nvim Sets the Neovim host instance as $EDITOR tree.nvim Neovim file-explorer powered by C++ vim-accio : Asynchronously summons build/compiler/linter output to your screen by wrapping the :compiler and :make commands vim-airline : See this commit vim-chat : Chat client for QQ and Weixin vim-composer : Support for Composer PHP projects vim-esearch : Perform search in files easily vim-ghost : Neovim client for GhostText browser extension on Firefox and Chrome vim-gitgutter : Shows a git diff in the gutter (sign column) and stages/undos hunks vim-go : See PR 607 for feature list vim-grepper : Use your favorite grep tool (ag, ack, git grep, ripgrep, pt, sift, findstr, grep) to start an asynchronous search vim-im-select : Improve Vim/Neovim experience with input methods vim-javacomplete2 : An omni-completion plugin for Java vim-man : View and grep man pages in Vim vim-markdown-composer : Asynchronous Markdown preview vim-netranger : Ranger-like system/cloud storage explorer vim-pandoc : Integrate with the Pandoc document converter and work with documents written in its Markdown variant vim-plug : Plugin manager vim-primary-terminal : Simple terminal management vim-rainbows : Runtime files for the Rainbow programming language vim-signify : Uses the sign column to indicate added, modified and removed lines in a file that is managed by a version control system (VCS) vim-test : Wrapper for running tests on different granularities vim-tmux-clipboard : Seamless integration with tmux's clipboard vimcmdline : Sends lines from either Vim or Neovim to a command line interpreter (REPL application) vsh : Store and replay shell sessions; also output search/modification/undo/redo worldslice : Minimalistic statusline and tabline configuration Non-plugin software This is software either targeted at Neovim or with support for it. chromatin : Package manager for plugins built with Ribosome neovim-remote : Tool that helps controlling Neovim processes nero.nvim : A REPL for Neovim (as in managing Neovim through a REPL) nfasd Autocomplete recent files in command line nvimdev : Help to Neovim development nvimpager : Use Neovim as $PAGER to view man pages, git logs, etc. with Neovim's syntax highlighting page : Advanced $PAGER , acts like neovim-remote, features fast CSI sequences processing ribosome : Framework for building and testing Python plugins tmux-resurrect : Restore tmux environment after system restart vmux : Vim/Neovim session handler within tmux Vroom : Way to specify Vim commands (actual input keys that that the user hits) and then verify Vim's output Colorschemes Color schemes make use of Neovim-specific features, e.g. highlight groups or terminal emulator colors. falcon flatcolor Deprecated use challenger-deep instead challenger-deep janah NeoSolarized oceanic-next onedark gruvbox vim-monokai","title":"Related-projects"},{"location":"Related-projects/#gui","text":"Platform Project Activity Atom Integration carlosdcastillo/vim-mode abandoned Avalonia yatli/fvim Browsers Firenvim C++/Python meatich/NeoSFML inactive C++/SDL2 etorth/libnvc curses/Python mvilim/neovim-pytc-example EFL Eovim Electron UI coolwanglu/neovim-e inactive Electron UI rhysd/NyaoVim Revery UI onivim/oni2 Electron UI onivim/oni Electron UI veonim Electron UI VV VSCode VSCodeVim VSCode Neo Vim gnome-terminal neovim-gnome-terminal-wrapper Go/Qt akiyosi/gonvim Go/Qt dzhou121/gonvim abandoned GTK/Python UI neovim/python-gui GTK/Python UI rliang/nvim-pygtk3 GTK/Rust UI daa84/neovim-gtk GTK/Rust UI GNvim JavaFX jebberjeb/javafx-neovimpane Konsole harish2704/neovim-konsole inactive macOS qvacua/vimr macOS rogual/neovim-dot-app mac OS UI DinVim Vim for Mac Terminal Wrapper glrnvim Qt 5 equalsraf/neovim-qt Qt Creator sassanh/qnvim Rust IDE oakes/SolidOak archived Sublime Text lunixbochs/actualvim Tk/Python UI timeyyy/pytknvim inactive Windows/Linux meatich/Viy inactive Note: Activity only takes into account the update of the codebase, excluding README, etc.","title":"GUI"},{"location":"Related-projects/#api-clients","text":"Platform Project C# neovim/nvim.net C++ DaikiMaekawa/neovim.cpp C++/Qt5 equalsraf/neovim-qt C++/ncurses SoC/neovim-client C++/Magnum Squareys/magnum-neovim-api Clojure jebberjeb/neovim-client Common Lisp adolenc/cl-neovim D viniarck/nvimhost-d Dart smolck/dart-nvim-api Elixir awetzel/neovim-elixir Filesystem fmoralesc/nvimfs Go neovim/go-client Haskell neovimhaskell/nvim-hs Java fdinoff/neovim-java-client Java esensar/neovim-java Julia bfredl/Neovim.jl Lua neovim/lua-client Node.js neovim/node-client Node.js neoclide/neovim OCaml janestreet/vcaml Perl yanick/Neovim-RPC Python neovim/pynvim R jalvesaq/Nvim-R Racket HiPhish/neovim.rkt Ruby neovim/neovim-ruby Rust oakes/neovim-rs [archived] Rust daa84/neovim-lib Scala viniarck/nvimhost-scala Swift/Cocoa NvimView (part of qvacua/vimr)","title":"API clients"},{"location":"Related-projects/#plugins","text":"The following plugins take advantage of specific Neovim features, e.g. jobstart() , :terminal or its remote plugin mechanism. acid.nvim : Asynchronous nREPL client for Clojure development aerojump.nvim : Filter as you type searcher/jumper with fuzzy matching. alchemist.vim : Elixir integration axe : Asynchronous executor for predefined custom commands bolt.nvim : Filter as you type file manager with fuzzy matching and ripgrep integration LeaderF : An asynchronous fuzzy finder which is used to quickly locate files, buffers, mrus, tags, gtags, etc. in large project. buildit.nvim : An async project builder, tries to detect the right builder for your project chromatica.nvim : Clang-based syntax highlighting coc.nvim : Completion and other language server support for Neovim, featured as VSCode Conjure : Clojure and ClojureScript tooling for Neovim over a socket prepl connection dein.vim : Plugin manager denite.nvim : Dark powered plugin for Neovim/Vim to unite all interfaces deoplete.nvim : Dark powered asynchronous completion framework Extract : Puts and yanks to a list with normal, visual swapping, and insert list/register completion far.vim : Search and replace Floobits : Floobits plugin FlyGrep.vim : Asynchronously fly grep in vim fzf-gitignore : A fzf (command-line fuzzy finder) interface for creating .gitignore files using the gitignore.io API gen_tags.vim : Async plugin for Vim and Neovim to ease the use of Ctags/gTags haskell-vim : Custom syntax highlighting and indentation Vimscripts for Haskell and Cabal InsertLeftBracket.nvim : Auto-complete brackets for Objective-C files iron.nvim : REPL management LanguageClient-neovim : Language Server Protocol (LSP) support for Neovim lldb.nvim : Debugger integration with a focus on ease-of-use markdown-preview.nvim : Preview Markdown files on your browser with synchronous scrolling; flexible configuration using Neovim's RPC API mirror.vim : Efficient way to edit remote files on multiple environments mkdx : Vim plugin that adds some nice extras for working with Markdown documents ncm2 : Slim, fast, and hackable completion framework for Neovim (fork of nvim-completion-manager) neogdb.vim : Vim GDB front-end for neovim written in python/vimscript neomake-multiprocess : Vim plugin for running multiple process asynchronously based on Neomake neomake : Asynchronous linting and make framework neopipe : Send lines of text to an external command and display output in a scratch buffer neotags.nvim : Plugin that generates and highlights Ctags neoterm : Wrapper of some Neovim's :terminal functions neotex : Latex live preview neovim-hackernews : Display Hacker News (HN) stories inside Neovim neovim-ranger : File manager with Vi key bindings neovim-vifm : Integration between Vifm (Vi file manager) and Neovim nim.nvim : Nim language support nlanguagetool.nvim : Integration with LanguageTool, a style and grammar checker for natural languages nuake : Quake-style terminal panel for Neovim nvim-completion-manager (deprecated): Fast, extensible, asynchronous completion framework nvim-editcommand : Edit your current shell command inside a scratch buffer nvim-gdb : Neovim thin wrapper for GDB, LLDB and PDB written in Moonscript/Lua nvim-go : Go development plugin for Neovim written in pure Go nvim-ipy : IPython/Jupyter integration nvim-luadev : REPL for developing lua plugins nvim-miniyank : Simple yankring (shared across instances) nvim-marksman - A file finder that minimizes the amount of keystrokes needed to go to a file nvim-moonmaker : Adds plugin support for MoonScript files in the same way the built-in support for Lua/Python files works (by automatically compiling MoonScript files to Lua) nvim-palette : Fuzzy search of settings Nvim-R : Plugin to work with R nvim-terminus : Edit your current command in a scratch buffer nvim-typescript : Asynchronous typescript tooling and completion nvimpam : Provides async folding for Pam-Crash files nvimux : Neovim as multiplexer with tmux keybindings orchestra.nvim : Bind sound effects to different actions proteome : Assists in working on multiple projects in a single Neovim instance semshi : Semantic highlighting for Python termedit.nvim Sets the Neovim host instance as $EDITOR tree.nvim Neovim file-explorer powered by C++ vim-accio : Asynchronously summons build/compiler/linter output to your screen by wrapping the :compiler and :make commands vim-airline : See this commit vim-chat : Chat client for QQ and Weixin vim-composer : Support for Composer PHP projects vim-esearch : Perform search in files easily vim-ghost : Neovim client for GhostText browser extension on Firefox and Chrome vim-gitgutter : Shows a git diff in the gutter (sign column) and stages/undos hunks vim-go : See PR 607 for feature list vim-grepper : Use your favorite grep tool (ag, ack, git grep, ripgrep, pt, sift, findstr, grep) to start an asynchronous search vim-im-select : Improve Vim/Neovim experience with input methods vim-javacomplete2 : An omni-completion plugin for Java vim-man : View and grep man pages in Vim vim-markdown-composer : Asynchronous Markdown preview vim-netranger : Ranger-like system/cloud storage explorer vim-pandoc : Integrate with the Pandoc document converter and work with documents written in its Markdown variant vim-plug : Plugin manager vim-primary-terminal : Simple terminal management vim-rainbows : Runtime files for the Rainbow programming language vim-signify : Uses the sign column to indicate added, modified and removed lines in a file that is managed by a version control system (VCS) vim-test : Wrapper for running tests on different granularities vim-tmux-clipboard : Seamless integration with tmux's clipboard vimcmdline : Sends lines from either Vim or Neovim to a command line interpreter (REPL application) vsh : Store and replay shell sessions; also output search/modification/undo/redo worldslice : Minimalistic statusline and tabline configuration","title":"Plugins"},{"location":"Related-projects/#non-plugin-software","text":"This is software either targeted at Neovim or with support for it. chromatin : Package manager for plugins built with Ribosome neovim-remote : Tool that helps controlling Neovim processes nero.nvim : A REPL for Neovim (as in managing Neovim through a REPL) nfasd Autocomplete recent files in command line nvimdev : Help to Neovim development nvimpager : Use Neovim as $PAGER to view man pages, git logs, etc. with Neovim's syntax highlighting page : Advanced $PAGER , acts like neovim-remote, features fast CSI sequences processing ribosome : Framework for building and testing Python plugins tmux-resurrect : Restore tmux environment after system restart vmux : Vim/Neovim session handler within tmux Vroom : Way to specify Vim commands (actual input keys that that the user hits) and then verify Vim's output","title":"Non-plugin software"},{"location":"Related-projects/#colorschemes","text":"Color schemes make use of Neovim-specific features, e.g. highlight groups or terminal emulator colors. falcon flatcolor Deprecated use challenger-deep instead challenger-deep janah NeoSolarized oceanic-next onedark gruvbox vim-monokai","title":"Colorschemes"},{"location":"Troubleshooting/","text":"Moved to https://github.com/neovim/neovim/wiki/FAQ","title":"Troubleshooting"},{"location":"UI-architecture/","text":"User Interface (UI) architecture The present paragraph is meant to help developers understand the UI source code. One of neovim goals is to make it possible to create (n)vim GUIs (Graphical UIs) without touching the core code. This is done via UI events sent over msgpack-rpc. These UIs ( nvim-qt , oni, nyaovim, ...) are called remote UI clients . Yet for compatibility reasons there exists another type of UI simply called (local?) UI clients which are more dependant on nvim changes. For instance the terminal UI (TUI) bypasses the msgpack-rpc layer. So does vimR . The source files most directly involved with UI events are: 1. src/nvim/ui.* : calls handler functions of registered UI structs (independant from msgpack-rpc) 2. src/nvim/api/ui.* : forwards messages over msgpack-rpc to remote UIs. 3. src/nvim/api/ui_bridge.* : similar to 2/ but forwards messages to UI threads (TUI for instance) as events UI events are defined in src/nvim/api/ui_events.in.h , this file is not compiled directly, rather it parsed by src/nvim/generators/gen_api_ui_events.lua which autogenerates wrapper functions used by the source files above. It also generates metadata accesible as api_info().ui_events . Please note that in both cases (local and remote), UI events may be deferred to UIs, which implies to do deepcopy of the UI events data. The difference between 2 and 3 is best seen in https://github.com/neovim/neovim/pull/6044 , ui_bridge_cursor_styleset_event and remote_ui_cursor_style_set are very similar, except remote_ui_cursor_style_set sends the event over msgpack, while ui_bridge_cursor_style_set pass it on to the local UI scheduler (src/nvim/tui.c:tui_scheduler for the TUI). Once you've finished your changes to neovim UI protocol, don't forget to update set(NVIM_API_LEVEL 2) # Bump this after any API change. in CMakeLists.txt Here are a few more references: * :help msgpack-rpc * :help ui * https://github.com/neovim/neovim/pull/3246 * http://tarruda.github.io/articles/neovim-smart-ui-protocol/","title":"UI-architecture"},{"location":"UI-architecture/#user-interface-ui-architecture","text":"The present paragraph is meant to help developers understand the UI source code. One of neovim goals is to make it possible to create (n)vim GUIs (Graphical UIs) without touching the core code. This is done via UI events sent over msgpack-rpc. These UIs ( nvim-qt , oni, nyaovim, ...) are called remote UI clients . Yet for compatibility reasons there exists another type of UI simply called (local?) UI clients which are more dependant on nvim changes. For instance the terminal UI (TUI) bypasses the msgpack-rpc layer. So does vimR . The source files most directly involved with UI events are: 1. src/nvim/ui.* : calls handler functions of registered UI structs (independant from msgpack-rpc) 2. src/nvim/api/ui.* : forwards messages over msgpack-rpc to remote UIs. 3. src/nvim/api/ui_bridge.* : similar to 2/ but forwards messages to UI threads (TUI for instance) as events UI events are defined in src/nvim/api/ui_events.in.h , this file is not compiled directly, rather it parsed by src/nvim/generators/gen_api_ui_events.lua which autogenerates wrapper functions used by the source files above. It also generates metadata accesible as api_info().ui_events . Please note that in both cases (local and remote), UI events may be deferred to UIs, which implies to do deepcopy of the UI events data. The difference between 2 and 3 is best seen in https://github.com/neovim/neovim/pull/6044 , ui_bridge_cursor_styleset_event and remote_ui_cursor_style_set are very similar, except remote_ui_cursor_style_set sends the event over msgpack, while ui_bridge_cursor_style_set pass it on to the local UI scheduler (src/nvim/tui.c:tui_scheduler for the TUI). Once you've finished your changes to neovim UI protocol, don't forget to update set(NVIM_API_LEVEL 2) # Bump this after any API change. in CMakeLists.txt Here are a few more references: * :help msgpack-rpc * :help ui * https://github.com/neovim/neovim/pull/3246 * http://tarruda.github.io/articles/neovim-smart-ui-protocol/","title":"User Interface (UI) architecture"},{"location":"Unit-tests/","text":"Moved to: https://github.com/neovim/neovim/blob/master/test/README.md","title":"Unit-tests"},{"location":"_Footer/","text":"This is the Neovim wiki. Wiki Home","title":" Footer"},{"location":"_Sidebar/","text":"[[https://raw.githubusercontent.com/neovim/neovim.github.io/master/logos/neovim-logo.png|alt=Neovim home]] Introduction FAQ Related projects Users Install Following HEAD Documentation Developers Build Contribute Tips & Tools Code style","title":" Sidebar"},{"location":"_Sidebar/#httpsrawgithubusercontentcomneovimneovimgithubiomasterlogosneovim-logopngaltneovim-home","text":"Introduction FAQ Related projects","title":"[[https://raw.githubusercontent.com/neovim/neovim.github.io/master/logos/neovim-logo.png|alt=Neovim home]]"},{"location":"_Sidebar/#users","text":"Install Following HEAD Documentation","title":"Users"},{"location":"_Sidebar/#developers","text":"Build Contribute Tips & Tools Code style","title":"Developers"}]}